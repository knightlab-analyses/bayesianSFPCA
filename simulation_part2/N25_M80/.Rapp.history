########## generate simulated data with N=100 and Orth=TRUE #######
#
rm(list=ls())#
list.files()#
#
library(Matrix)#
set.seed(31)#
#
###############################
###############################
##  SIMULATION PARAMETERS   ###
###############################
###############################
#
source("simulate_data_sparse.R")#
source("basis_setup_sparse.R")#
#
T_min=0;T_max=1;T_range=c(T_min,T_max)#
N_T_max=10;N_T_mean=2#
P=2#
N=100#
nknots=c(1,2)#
params=list()#
orth=TRUE#
#
Q_true=c(2,2) # number of modes of variation (i.e. number of PCs)#
R_true=diag(rep(1,sum(Q_true)));R_true[1,4]=.75;R_true[4,1]=R_true[1,4] # correlation of FPCA scores#
D_true=diag(rep(1,sum(Q_true)));D_true[1,1]=2;D_true[3,3]=2; #D_true=0.1*D_true # standard deviations of FPCA scores#
SIGMA_ALPHA_true=D_true%*%R_true%*%D_true # Variance-covariance matrix of FPCA scores#
SIGMA_OMEGA_true=0.01*rep(1,P) # Error variances#
#MU_true=rep(0,sum(nknots+4)) # Coefficients of basis functions for mean curves across subjects#
#MU_true=c(c(1.8,.8,.4,.2,-1.2),c(-1.8,-.8,-.4,-.2,0,0))#
MU_true=c(c(1.8, .8, .4, .2, -1.2), #
		  c(0.125689927, 0.085802413, -0.107942359, -0.164469410, -0.009916578, -0.081660406))#
## set up FPC_true#
time=seq(T_range[1],T_range[2],(T_range[2]-T_range[1])/(N_T_max-1))#
time_sparse=list()#
for(i in 1:N){#
	time_sparse[[i]]=list()#
	for(p in 1:P){#
		time_sparse[[i]][[p]]=time#
	}#
}#
basis_stuff=basis_setup_sparse(time_sparse,nknots, orth=orth)#
knots=basis_stuff[[1]]#
time_sparse=basis_stuff[[2]]#
time_sparse_combined=basis_stuff[[3]]#
phi_t=basis_stuff[[4]]#
time_cont=basis_stuff[[5]]#
phi_t_cont=	basis_stuff[[6]]#
Phi_D=basis_stuff[[7]]#
Phi_D_T=basis_stuff[[8]]#
#
# FPCA loadings#
if(nknots[2]==1){#
	THETA_true=cbind(c(0.40529575,0.82201395,0.39930063,-0.02187301,-0.01044030,rep(0,5)),#
		c(0.06137363,0.10733627,-0.33973487,-0.81361591,-0.45532579,rep(0,5)),#
		c(rep(0,5),0.3490362,0.7295541,0.5036934,0.2608049,0.1555581),#
		c(rep(0,5),0.2280605,0.3930486,-0.2056171,-0.7682501,-0.4012662))#
}#
if(nknots[2]==2){#
	THETA_true=cbind(c(0.40529575,0.82201395,0.39930063,-0.02187301,-0.01044030,rep(0,6)),#
		c(0.06137363,0.10733627,-0.33973487,-0.81361591,-0.45532579,rep(0,6)),#
		# c(rep(0,5),0.3490362,0.7295541,0.5036934,0.2608049,0.1555581,.075),#
		# c(rep(0,5),0.2280605,0.3930486,-0.2056171,-0.7682501,-0.4012662,0))#
		c(rep(0,5), 0.1734486, 0.2471184, 0.5260293, 0.5316424, 0.4836753, 0.2758460),#
		c(rep(0,5), 0.79569747, 0.31964112, -0.16640001, -0.17366537, -0.04200097, -0.05197922))#
}#
#
FPC_true=array(0,dim=c(N_T_max,sum(Q_true)))#
for(t in 1:N_T_max){#
	ind=0#
	for(q in 1:length(Q_true)){#
		FPC_true[t,(ind+1):(ind+Q_true[q])]=(Phi_D[[1]][[t]]%*%THETA_true)[q,(ind+1):(ind+Q_true[q])]#
		ind=ind+Q_true[q]#
	}	#
}#
#
## Set up param list#
#
params[[1]]=nknots#
params[[2]]=Q_true#
params[[3]]=R_true#
params[[4]]=D_true#
params[[5]]=SIGMA_OMEGA_true#
params[[6]]=THETA_true#
params[[7]]=MU_true#
params[[8]]=FPC_true#
#
########################
########################
##   GENERATE DATA   ###
########################
########################
#
TIME_SPARSE=list()#
Y_SPARSE=list()#
MU_SPARSE=list()#
F_SPARSE=list()#
OMEGA_SPARSE=list()#
ALPHA=list()#
#
nsims=1#
for(ii in 1:nsims){#
    simdata=simulate_data_sparse(T_range=T_range,N_T_max=N_T_max,N_T_mean=N_T_mean,P,N,params,orth=orth)#
	TIME_SPARSE[[ii]]=simdata[[1]]#
	Y_SPARSE[[ii]]=simdata[[2]]#
	MU_SPARSE[[ii]]=simdata[[3]]#
	F_SPARSE[[ii]]=simdata[[4]]#
	OMEGA_SPARSE[[ii]]=simdata[[5]]#
	ALPHA[[ii]]=simdata[[6]]#
}#
#
phi_t = simdata[[9]]#
####### warning: need to be called the following name, otherwise need to change the default in mfpca.R#
save(file="sim_N100_Orth.RData",TIME_SPARSE,Y_SPARSE,MU_SPARSE,F_SPARSE,OMEGA_SPARSE,ALPHA,params,knots,time, phi_t)#
##############################
##############################
##  RUN MULTI-FPCA MODEL   ###
##############################
##############################
#
# rm(list=ls())#
#
source("mfpca.R") ## need to change the loaded simulation file in mfpca.R code#
load("sim_N100_Orth.RData")#
#
nsims=length(Y_SPARSE)#
sim_results=list()#
for(ii in 1:nsims){#
		Y_sparse=Y_SPARSE[[ii]]#
		time_sparse=TIME_SPARSE[[ii]]#
		N=length(Y_sparse)#
		group=rep(1,N)#
		Q=c(2,2)#
		nknots=c(1,2)#
		nloop=150#
		burnin=50#
		thin=10#
		orth=TRUE#
		sim=TRUE#
		sim_results[[ii]]=mfpca(Y_sparse=Y_sparse,time_sparse=time_sparse,#
			group=group,Q,nknots=nknots,nloop=nloop,burnin=burnin,thin=thin,orth=orth,sim=TRUE)#
}#
save.image(file="sim_results_N100_Orth.Rdata")#
#######################
#######################
##  CHECK RESULTS   ###
#######################
#######################
#
# rm(list=ls())#
load("sim_results_N100_Orth.Rdata")#
#
ALPHA_array=sim_results[[1]][[1]]#
MU_array=sim_results[[1]][[2]]#
D_array=sim_results[[1]][[3]]#
R_array=sim_results[[1]][[4]]#
SIGMA_OMEGA_array=sim_results[[1]][[5]]#
THETA_array=sim_results[[1]][[6]]#
basis_stuff=sim_results[[1]][[7]]#
knots=basis_stuff[[1]]#
time_sparse=basis_stuff[[2]]#
phi_t=basis_stuff[[3]]#
time_cont=basis_stuff[[4]]#
phi_t_cont=basis_stuff[[5]]#
params=sim_results[[1]][[8]]#
nknots=params[[1]]#
Q_true=params[[2]]#
R_true=params[[3]]#
D_true=params[[4]]#
SIGMA_OMEGA_true=params[[5]]#
THETA_true=params[[6]]#
MU_true=params[[7]]#
FPC_true=params[[8]]#
#
### start plotting#
#
nloop=length(ALPHA_array)#
first=1#
last=nloop#
#
#plot mean functions#
MU_mean=MU_array[[1]]#
for(iter in 2:nloop){#
	MU_mean=MU_mean+MU_array[[iter]]#
}#
MU_mean=cbind(MU_mean/(last-first+1))#
Mu_true_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_true#
Mu_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_mean#
Mu1_true=Mu_true_functions[1:length(time_cont)]#
Mu2_true=Mu_true_functions[(length(time_cont)+1):(2*length(time_cont))]#
Mu1=Mu_functions[1:length(time_cont)]#
Mu2=Mu_functions[(length(time_cont)+1):(2*length(time_cont))]#
#
pdf('plots_mfpca.pdf')#
### figure 1: mean curve on individual spagetti plots#
par(mfrow=c(2,2))#
#par(mfrow=c(1,2))#
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4)#
for(i in 1:N){#
	lines(time_sparse[[i]][[1]],Y_sparse[[i]][[1]],type="l",lwd=.25)#
}#
lines(time_cont,Mu1,type="l",col=1,lwd=2)#
#abline(a=0,b=0,col=4,lwd=1)#
title(main="Y1")#
plot(time_cont,Mu2_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4)#
for(i in 1:N){#
	lines(time_sparse[[i]][[2]],Y_sparse[[i]][[2]],type="l",lwd=.25)#
}#
lines(time_cont,Mu2,type="l",col=1,lwd=2)#
#abline(a=0,b=0,col=4,lwd=1)#
title(main="Y2")#
#### figure 2: plot FPC curves (dominant modes) #
THETA_mean=THETA_array[[first]]#
for(iter in 2:nloop){#
	THETA_mean=THETA_mean+THETA_array[[iter]]#
}#
THETA_mean=cbind(THETA_mean/(last-first+1))#
#
FPC1_mean=t(phi_t_cont[[1]])%*%THETA_mean[1:5,1:2]#
FPC2_mean=t(phi_t_cont[[2]])%*%THETA_mean[6:11,3:4]#
#
#par(mfrow=c(1,2))#
plot(time,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)))#
lines(time,FPC_true[,2],type="l",lwd=1)#
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)#
title(main="PFCs for Variable 1")#
plot(time,FPC_true[,3],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)))#
lines(time,FPC_true[,4],type="l",lwd=1)#
lines(time_cont,FPC2_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC2_mean[,2],type="l",lwd=1,col=2)#
title(main="PFCs for Variable 2")#
dev.off()
library(parallel)#
library(rstan)#
library(loo)#
library(Matrix)#
#
options(mc.cores = parallel::detectCores())#
source('../../../../sfpca.R')#
#
#### test on simulated code#
load("sim_N100_Orth.RData", dat <- new.env())#
#ls.str(dat) #
#
## true values of parameters#
J = 2#
N = length(dat$Y_SPARSE[[1]])#
nknots = dat$params[[1]][[J]] #
Q = nknots + 4 # number of basis#
K = dat$params[[2]][[J]] # number of PC#
sigma_eps = sqrt(dat$params[[5]][[J]]) # SIGMA_OMEGA_true is error variance#
#
Q1 = dat$params[[1]][[1]] + 4#
K1 = dat$params[[2]][[1]]#
#
Theta = dat$params[[6]][(1+Q1):(Q+Q1), (1+K1):(K+K1)] # THETA_true#
theta_mu = dat$params[[7]][(1+Q1):(Q+Q1)] # MU_true#
ALPHA = t(dat$ALPHA[[1]][(1+K1):(K+K1), ]) # ALPHA#
Group = ifelse(ALPHA[, 1] > -0.1, 'G1', 'G2') # 49 in G1 and 51 in G2#
#
# basis#
phi_t = dat$phi_t[[J]]#
phi_t_stacked=NULL#
for(i in 1:N){#
	phi_t_stacked = rbind(phi_t_stacked, t(phi_t[[i]]))#
}#
## simulated data#
time = Y = MU = F = Omega = Alpha = list() #
ids=rep(1:N,each=1)#
#
for (i in 1:N){#
	time[[i]] = dat$TIME_SPARSE[[1]][[i]][[J]]#
	Y[[i]] = dat$Y_SPARSE[[1]][[i]][[J]]#
	MU[[i]] = dat$MU_SPARSE[[1]][[i]][[J]]#
	F[[i]] = dat$F_SPARSE[[1]][[i]][[J]]#
	Omega[[i]] = dat$OMEGA_SPARSE[[1]][[i]][[J]]#
}#
#
## convert data to data frame#
nrows = length(unlist(time))#
nvisits = sapply(time, length)#
df = data.frame(matrix(rep(0, nrows * 3), nrow=nrows))#
colnames(df) = c('id', 'time', 'response')#
for (j in 1:nrows){#
	df$id = rep(1:N, nvisits)#
	df$time = unlist(time)#
	df$response = unlist(Y)#
}#
#
# add group assigment#
id.list = unique(df$id)#
df$group = rep(0, nrows)#
for (i in 1:length(id.list)){#
	df$group[df$id == id.list[i]] = Group[i]#
}#
#
## plot ground truth scatterplot and spaghetti plot#
# reference: https://www.r-bloggers.com/my-commonly-done-ggplot2-graphs/#
library(ggplot2)#
ggplot(df, aes(x=time, y=response)) + geom_line() + guides(colour=FALSE) + #
xlab("Observation Time Point") + ylab("Response") + aes(colour = factor(id)) +#
facet_wrap(~ group) + # by different groups#
geom_smooth(se=FALSE, colour="black", size=1) # add mean smooth line#
ggsave('Observed_spaghetti_groups.pdf')#
scores_true = cbind.data.frame(as.vector(ALPHA[,1]), as.vector(ALPHA[,2]), Group, stringsAsFactors = FALSE)#
colnames(scores_true ) = c('fpc1', 'fpc2', 'group')#
ggplot(scores_true , aes(x=fpc1 , y=fpc2)) + geom_point() + aes(colour=factor(group)) #
ggsave('scatterplot_scores_truth.pdf')#
#
pdf('fpcScores_true_scatterplots.pdf')#
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='FPC1 Score', ylab='FPC2 Score', col=colors,#
     main='True scores')#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16), cex=0.8)#
dev.off()#
#
## data preparation#
prepared_data = prepare_data(data=df, unique_subject_id = 'id', time_var='time', response='response')#
results_basis = basis_setup_sparse(prepared_data=prepared_data, nknots=nknots, orth=TRUE)#
#
## check whether my generated basis is the same as the simulated one: should always be equal#
sum(results_basis$orth_spline_basis_sparse_stacked) == sum(phi_t_stacked) #
##################### run sfpca stan model ###############
Nsamples = 1000#
Nchains = 3#
#
model_file = "../../../../sfpca2.stan"#
smod = stan_model(model_file)#
#
pca_data <- list(N = prepared_data$num_subjects, K = K, Q = Q, Y = prepared_data$response.list,#
		             V = prepared_data$visits.vector, subject_starts = prepared_data$visits.start,#
			   	     subject_stops = prepared_data$visits.stop, cov_starts = prepared_data$cov.start,#
			   	     cov_stops = prepared_data$cov.stop,#
			   	     cov_size = prepared_data$cov.size, B = phi_t_stacked)#
set.seed(31)#
sa.list = sampling(smod, data= pca_data, iter=Nsamples, chains=Nchains,init="random")#
log_lik.list <- extract(sa.list,"log_lik_marg")[[1]]#
looic.list = loo(log_lik.list)#
save(sa.list,log_lik.list,looic.list,file="sfpca_results_N100_Orth_G2.RData")#
#
################## predictive model checking (need to re-run Stan as it was updated with predictive distribution)#
sa = sa.list#
Ynew = extract(sa,"Ynew",permuted=FALSE)#
V = prepared_data$visits.vector#
Ynew_transform = matrix(rep(0, Nsamples/2 * Nchains * sum(V)), ncol=sum(V))#
ind = 0#
for (i in 1:(Nsamples/2)){#
	for (j in 1:Nchains){#
		ind = ind + 1#
		Ynew_transform[ind, ] = Ynew[i,j,]#
	}#
}#
#
library("bayesplot")#
library("ggplot2")#
pdf('predictive_cheking.pdf')#
ppc_dens_overlay(df$response, Ynew_transform)#
dev.off()
