dfm3 <- df_orig
dfm4 <- df_orig
dfm5 <- df_orig
z <- c(0,0.02,0.12,0.35,0.45,.55,0.45,0.38,0.2,0.1,0.01,0)  # Values by which to perturb the data
shifter <- c(z,z,z,z,z,z,z,z,z,z)
dfm2$Version <- 'baseline'
# Make perturbed data at several magnitudes by scaling z
dfm3$response <- dfm2$response + (dfm2$response * (shifter/20))
dfm3$Version <- 'shift_1x'; dfm3$patient <- paste(dfm3$patient, '1x', sep = '_')
dfm4$response <- dfm2$response + (dfm2$response * (shifter/10))
dfm4$Version <- 'shift_2x'; dfm4$patient <- paste(dfm4$patient, '2x', sep = '_')
dfm5$response <- dfm2$response + (dfm2$response * (shifter/5))
dfm5$Version <- 'shift_4x'; dfm5$patient <- paste(dfm5$patient, '4x', sep = '_')
dfm_bound <- rbind(dfm2, dfm3, dfm4, dfm5)
dfm_loess <- ggplot(dfm_bound) + geom_smooth(aes(x=time, y=response, color=Version), se = F, method = 'loess') +
geom_point(aes(x=time, y=response, color=Version), alpha=0.5, size=1.2) +
theme_classic() + theme(axis.text = element_text(color='black')) +
scale_color_manual(values=colpal)
dfm_loess
dfm_lm <- ggplot(dfm_bound) + geom_smooth(aes(x=time, y=response, color=Version), se = F, method = 'lm') +
geom_point(aes(x=time, y=response, color=Version), alpha=0.5, size=1.2) +
theme_classic() + theme(axis.text = element_text(color='black')) +
scale_color_manual(values=colpal)
dfm_lm
permu_result1 <- permuspliner(data = dfm_bound, xvar='time', yvar='response',
cases = 'patient', category = 'Version',
perms = 99, groups = c('baseline','shift_1x'))
permu_result2 <- permuspliner(data = dfm_bound, xvar='time', yvar='response',
cases = 'patient', category = 'Version',
perms = 999, groups = c('baseline','shift_2x'))
permu_result4 <- permuspliner(data = dfm_bound, xvar='time', yvar='response',
cases = 'patient', category = 'Version',
perms = 999, groups = c('baseline','shift_4x'))
head(dfm_bound)
permuspliner.plot.permdistance(permu_result4, xlabel = 'time')
permuspliner.plot.permsplines(permu_result4, xvar = 'time', yvar = 'response')
df2 <- df_orig
df3 <- df_orig
df4 <- df_orig
df5 <- df_orig
z <- c(0,0.2,.4,0.4,0.2,0.05,-.1,-.2,-.38,-0.3,-.1,0)  # Scale to perturb the data
shifter2 <- c(z,z,z,z,z,z,z,z,z,z)
df2$Version <- 'baseline'
# Make perturbed data at several magnitudes by scaling z
df3$response <- df2$response + (df2$response * (shifter2/20))
df3$Version <- 'shift_1x'; df3$patient <- paste(df3$patient, '1x', sep = '_')
df4$response <- df2$response + (df2$response * (shifter2/10))
df4$Version <- 'shift_2x'; df4$patient <- paste(df4$patient, '2x', sep = '_')
df5$response <- df2$response + (df2$response * (shifter2/5))
df5$Version <- 'shift_4x'; df5$patient <- paste(df5$patient, '4x', sep = '_')
df_bound <- rbind(df2, df3, df4, df5)
df_loess <- ggplot(df_bound) + geom_smooth(aes(x=time, y=response, color=Version), se = F, method = 'loess') +
geom_point(aes(x=time, y=response, color=Version), alpha=0.5, size=1.2) +
theme_classic() + theme(axis.text = element_text(color='black')) +
scale_color_manual(values=colpal)
df_loess
df_lm <- ggplot(df_bound) + geom_smooth(aes(x=time, y=response, color=Version), se = F, method = 'lm') +
geom_point(aes(x=time, y=response, color=Version), alpha=0.5, size=1.2) +
theme_classic() + theme(axis.text = element_text(color='black')) +
scale_color_manual(values=colpal)
df_lm
### simulation setting for splinectomeR ####library(ggplot2)
library(reshape2)
#library(splinectomeR)
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
df_orig <- data.frame(matrix(ncol=3, nrow = 120))
colnames(df_orig) <- c('patient','time','response')
ids <- c(1,2,3,4,5,6,7,8,9,10)
timeseries <- c(0,2,4,6,8,10,12,14,16,18,20,22)
patient <- unlist(lapply(X = ids, FUN = function(xx) rep(xx, times=12)))
set.seed(7)
obs <- c(rnorm(n=10, mean = 100, sd = 2),  # Make a distribution at each timepoint
rnorm(n=10, mean = 100, sd = 4),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 8),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 4),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 8),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 4),
rnorm(n=10, mean = 100, sd = 3),
rnorm(n=10, mean = 100, sd = 2))
df_orig$patient <- patient
df_orig$time <-rep(timeseries, times = 10)
df_orig$response <- obs
df <- df_orig
#### A bump in the middle ####
dfm2 <- df_orig
dfm3 <- df_orig
dfm4 <- df_orig
dfm5 <- df_orig
z <- c(0,0.02,0.12,0.35,0.45,.55,0.45,0.38,0.2,0.1,0.01,0)  # Values by which to perturb the data
shifter <- c(z,z,z,z,z,z,z,z,z,z)
dfm2$Version <- 'baseline'
# Make perturbed data at several magnitudes by scaling z
dfm3$response <- dfm2$response + (dfm2$response * (shifter/20))
dfm3$Version <- 'shift_1x'; dfm3$patient <- paste(dfm3$patient, '1x', sep = '_')
dfm4$response <- dfm2$response + (dfm2$response * (shifter/10))
dfm4$Version <- 'shift_2x'; dfm4$patient <- paste(dfm4$patient, '2x', sep = '_')
dfm5$response <- dfm2$response + (dfm2$response * (shifter/5))
dfm5$Version <- 'shift_4x'; dfm5$patient <- paste(dfm5$patient, '4x', sep = '_')
dfm_bound <- rbind(dfm2, dfm3, dfm4, dfm5)
dfm_loess <- ggplot(dfm_bound) + geom_smooth(aes(x=time, y=response, color=Version), se = F, method = 'loess') +
geom_point(aes(x=time, y=response, color=Version), alpha=0.5, size=1.2) +
theme_classic() + theme(axis.text = element_text(color='black')) +
scale_color_manual(values=colpal)
#ggsave(dfm_loess, filename = '~/Box Sync/knights_box/splinectomer/doc/manuscript/figures/FigXA_dfmloess.png', width = 4, height = 3, dpi=600)
dfm_lm <- ggplot(dfm_bound) + geom_smooth(aes(x=time, y=response, color=Version), se = F, method = 'lm') +
geom_point(aes(x=time, y=response, color=Version), alpha=0.5, size=1.2) +
theme_classic() + theme(axis.text = element_text(color='black')) +
scale_color_manual(values=colpal)
#ggsave(dfm_lm, filename = '~/Box Sync/knights_box/splinectomer/doc/manuscript/figures/FigXA_dfmlm.png', width = 4, height = 3, dpi=600)
### simulation setting for splinectomeR ####library(ggplot2)
library(ggplot2)
library(reshape2)
#library(splinectomeR)
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
df_orig <- data.frame(matrix(ncol=3, nrow = 120))
colnames(df_orig) <- c('patient','time','response')
ids <- c(1,2,3,4,5,6,7,8,9,10)
timeseries <- c(0,2,4,6,8,10,12,14,16,18,20,22)
patient <- unlist(lapply(X = ids, FUN = function(xx) rep(xx, times=12)))
set.seed(7)
obs <- c(rnorm(n=10, mean = 100, sd = 2),  # Make a distribution at each timepoint
rnorm(n=10, mean = 100, sd = 4),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 8),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 4),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 8),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 4),
rnorm(n=10, mean = 100, sd = 3),
rnorm(n=10, mean = 100, sd = 2))
df_orig$patient <- patient
df_orig$time <-rep(timeseries, times = 10)
df_orig$response <- obs
df <- df_orig
#### A bump in the middle ####
dfm2 <- df_orig
dfm3 <- df_orig
dfm4 <- df_orig
dfm5 <- df_orig
z <- c(0,0.02,0.12,0.35,0.45,.55,0.45,0.38,0.2,0.1,0.01,0)  # Values by which to perturb the data
shifter <- c(z,z,z,z,z,z,z,z,z,z)
dfm2$Version <- 'baseline'
# Make perturbed data at several magnitudes by scaling z
dfm3$response <- dfm2$response + (dfm2$response * (shifter/20))
dfm3$Version <- 'shift_1x'; dfm3$patient <- paste(dfm3$patient, '1x', sep = '_')
dfm4$response <- dfm2$response + (dfm2$response * (shifter/10))
dfm4$Version <- 'shift_2x'; dfm4$patient <- paste(dfm4$patient, '2x', sep = '_')
dfm5$response <- dfm2$response + (dfm2$response * (shifter/5))
dfm5$Version <- 'shift_4x'; dfm5$patient <- paste(dfm5$patient, '4x', sep = '_')
dfm_bound <- rbind(dfm2, dfm3, dfm4, dfm5)
dfm_loess <- ggplot(dfm_bound) + geom_smooth(aes(x=time, y=response, color=Version), se = F, method = 'loess') +
geom_point(aes(x=time, y=response, color=Version), alpha=0.5, size=1.2) +
theme_classic() + theme(axis.text = element_text(color='black')) +
scale_color_manual(values=colpal)
#ggsave(dfm_loess, filename = '~/Box Sync/knights_box/splinectomer/doc/manuscript/figures/FigXA_dfmloess.png', width = 4, height = 3, dpi=600)
dfm_lm <- ggplot(dfm_bound) + geom_smooth(aes(x=time, y=response, color=Version), se = F, method = 'lm') +
geom_point(aes(x=time, y=response, color=Version), alpha=0.5, size=1.2) +
theme_classic() + theme(axis.text = element_text(color='black')) +
scale_color_manual(values=colpal)
#ggsave(dfm_lm, filename = '~/Box Sync/knights_box/splinectomer/doc/manuscript/figures/FigXA_dfmlm.png', width = 4, height = 3, dpi=600)
dfm_loess
dfm_lm
### simulation setting for splinectomeR ####library(ggplot2)
library(ggplot2)
library(reshape2)
#library(splinectomeR)
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
df_orig <- data.frame(matrix(ncol=3, nrow = 120))
colnames(df_orig) <- c('patient','time','response')
ids <- c(1,2,3,4,5,6,7,8,9,10)
timeseries <- c(0,2,4,6,8,10,12,14,16,18,20,22)
patient <- unlist(lapply(X = ids, FUN = function(xx) rep(xx, times=12)))
set.seed(7)
obs <- c(rnorm(n=10, mean = 100, sd = 2),  # Make a distribution at each timepoint
rnorm(n=10, mean = 100, sd = 4),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 8),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 4),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 8),
rnorm(n=10, mean = 100, sd = 6),
rnorm(n=10, mean = 100, sd = 4),
rnorm(n=10, mean = 100, sd = 3),
rnorm(n=10, mean = 100, sd = 2))
df_orig$patient <- patient
df_orig$time <-rep(timeseries, times = 10)
df_orig$response <- obs
df <- df_orig
#### A bump in the middle ####
dfm2 <- df_orig
dfm3 <- df_orig
dfm4 <- df_orig
dfm5 <- df_orig
z <- c(0,0.02,0.12,0.35,0.45,.55,0.45,0.38,0.2,0.1,0.01,0)  # Values by which to perturb the data
shifter <- c(z,z,z,z,z,z,z,z,z,z)
dfm2$Version <- 'baseline'
# Make perturbed data at several magnitudes by scaling z
dfm3$response <- dfm2$response + (dfm2$response * (shifter/20))
dfm3$Version <- 'shift_1x'; dfm3$patient <- paste(dfm3$patient, '1x', sep = '_')
dfm4$response <- dfm2$response + (dfm2$response * (shifter/10))
dfm4$Version <- 'shift_2x'; dfm4$patient <- paste(dfm4$patient, '2x', sep = '_')
dfm5$response <- dfm2$response + (dfm2$response * (shifter/5))
dfm5$Version <- 'shift_4x'; dfm5$patient <- paste(dfm5$patient, '4x', sep = '_')
dfm_bound <- rbind(dfm2, dfm3, dfm4, dfm5)
dfm_loess <- ggplot(dfm_bound) + geom_smooth(aes(x=time, y=response, color=Version), se = F, method = 'loess') +
geom_point(aes(x=time, y=response, color=Version), alpha=0.5, size=1.2) +
theme_classic() + theme(axis.text = element_text(color='black')) +
scale_color_manual(values=colpal)
ggsave(dfm_loess, filename = 'FigXA_dfmloess.png', width = 4, height = 3, dpi=600)
dfm_lm <- ggplot(dfm_bound) + geom_smooth(aes(x=time, y=response, color=Version), se = F, method = 'lm') +
geom_point(aes(x=time, y=response, color=Version), alpha=0.5, size=1.2) +
theme_classic() + theme(axis.text = element_text(color='black')) +
scale_color_manual(values=colpal)
ggsave(dfm_lm, filename = 'FigXA_dfmlm.png', width = 4, height = 3, dpi=600)
c(rep(2,5),rep(-2,5),rep(.1,990)
)
library(c060)
res <- stabpath(y,x,weakness=1,mc.cores=2)
plot(res,error=.5,type='pfer')
set.seed(1234)
x=matrix(rnorm(100*1000,0,1),100,1000)
y <- x[1:100,1:1000]%*%c(rep(2,5),rep(-2,5),rep(.1,990))
library(c060)
res <- stabpath(y,x,weakness=1,mc.cores=2)
plot(res,error=.5,type='pfer')
log(0)
exp(1)
exp(-3)
bodyfat <- matrix(rnorm(720), nrow = 72, ncol = 10)
head(bodyfat)
(stab.lasso <- stabsel(x = bodyfat[, -2], y = bodyfat[,2],
fitfun = lars.lasso, cutoff = 0.75,
PFER = 1))
par(mfrow = c(2, 1))
plot(stab.lasso, ymargin = 6)
opar <- par(mai = par("mai") * c(1, 1, 1, 2.7))
plot(stab.lasso, type = "paths")
set.seed(1234)
library(stabs)
(stab.lasso <- stabsel(x = bodyfat[, -2], y = bodyfat[,2],
fitfun = lars.lasso, cutoff = 0.75,
PFER = 1))
par(mfrow = c(2, 1))
plot(stab.lasso, ymargin = 6)
opar <- par(mai = par("mai") * c(1, 1, 1, 2.7))
plot(stab.lasso, type = "paths")
stab.lasso
stab.select <- stabsel(x=x, y=y, fitfun=lars.lasso, cutoff=0.6, PFER=0.5)
stab.select
set.seed(1234)
x=matrix(rnorm(100*1000,0,1),100,1000)
dim(x)
y <- x %*% c(rep(2,5),rep(-2,5),rep(.1,990))
library(c060) # test on library(c060)
res <- stabpath(y,x,weakness=1,mc.cores=2)
plot(res,error=.5,type='pfer')
plot(res,error=.05,type='pcer')
library(stabs)
stab.select <- stabsel(x, y, fitfun=lars.lasso, cutoff=0.6, PFER=0.5, sampling.type='MB')
names(stab.select)
stab.select
system.time(res)
system.time(stabpath(y,x,weakness=1,mc.cores=2))
plot(res,error=.5,type='pfer')
system.time(stabsel(x, y, fitfun=lars.lasso, cutoff=0.6, PFER=0.5, sampling.type='MB'))
install.packages('plsgenomics')
library(plsgenomics)
### generating data
n <- 100
p <- 100
sample1 <- sample.cont(n=n, p=p, kstar=10, lstar=2,
beta.min=0.25, beta.max=0.75, mean.H=0.2,
sigma.H=10, sigma.F=5, sigma.E=5)
X <- sample1$X
Y <- sample1$Y
dim(X)
dim(Y)
head(X)
lambda.l1.range <- seq(0.05,0.95,by=0.1) # between 0 and 1
ncomp.range <- 1:10
### tuning the hyper-parameters
stab1 <- spls.stab(X=X, Y=Y, lambda.l1.range=lambda.l1.range,
ncomp.range=ncomp.range, weight.mat=NULL,
adapt=FALSE, center.X=TRUE, center.Y=TRUE,
scale.X=TRUE, scale.Y=TRUE, weighted.center=FALSE,
ncores=1, nresamp=100)
str(stab1)
stab1$probs.lambda
dim(probs.lambda)
dim(stab1$probs.lambda)
length(lambda.l1.range )
str(stab1)
dim(X)
stability.selection(stab1, piThreshold=0.6, rhoError=10)
plot(res,error=2,type='pfer')
setwd("~/Study/thesis/Bayesian/sfpca/simulation_microbiome/code_2D/sim_Babies_1D_2G/N50_C20")
library(parallel)
library(rstan)
library(loo)
library(Matrix)
options(mc.cores = parallel::detectCores())
source('../../../../sfpca.R')
#### test on simulated code
load("sim_N100_Orth.RData", dat <- new.env())
#ls.str(dat)
## true values of parameters
J = 2
N = length(dat$Y_SPARSE[[1]])
nknots = dat$params[[1]][[J]]
Q = nknots + 4 # number of basis
K = dat$params[[2]][[J]] # number of PC
sigma_eps = sqrt(dat$params[[5]][[J]]) # SIGMA_OMEGA_true is error variance
Q1 = dat$params[[1]][[1]] + 4
K1 = dat$params[[2]][[1]]
Theta = dat$params[[6]][(1+Q1):(Q+Q1), (1+K1):(K+K1)] # THETA_true
theta_mu = dat$params[[7]][(1+Q1):(Q+Q1)] # MU_true
ALPHA = t(dat$ALPHA[[1]][(1+K1):(K+K1), ]) # ALPHA
Group = ifelse(ALPHA[, 1] > -0.1, 'G1', 'G2') # 49 in G1 and 51 in G2
# basis
phi_t = dat$phi_t[[J]]
phi_t_stacked=NULL
for(i in 1:N){
phi_t_stacked = rbind(phi_t_stacked, t(phi_t[[i]]))
}
## simulated data
time = Y = MU = F = Omega = Alpha = list()
ids=rep(1:N,each=1)
for (i in 1:N){
time[[i]] = dat$TIME_SPARSE[[1]][[i]][[J]]
Y[[i]] = dat$Y_SPARSE[[1]][[i]][[J]]
MU[[i]] = dat$MU_SPARSE[[1]][[i]][[J]]
F[[i]] = dat$F_SPARSE[[1]][[i]][[J]]
Omega[[i]] = dat$OMEGA_SPARSE[[1]][[i]][[J]]
}
## convert data to data frame
nrows = length(unlist(time))
nvisits = sapply(time, length)
df = data.frame(matrix(rep(0, nrows * 3), nrow=nrows))
colnames(df) = c('id', 'time', 'response')
for (j in 1:nrows){
df$id = rep(1:N, nvisits)
df$time = unlist(time)
df$response = unlist(Y)
}
# add group assigment
id.list = unique(df$id)
df$group = rep(0, nrows)
for (i in 1:length(id.list)){
df$group[df$id == id.list[i]] = Group[i]
}
## plot ground truth scatterplot and spaghetti plot
# reference: https://www.r-bloggers.com/my-commonly-done-ggplot2-graphs/
library(ggplot2)
ggplot(df, aes(x=time, y=response)) + geom_line() + guides(colour=FALSE) +
xlab("Observation Time Point") + ylab("Response") + aes(colour = factor(id)) +
facet_wrap(~ group) + # by different groups
geom_smooth(se=FALSE, colour="black", size=1) # add mean smooth line
ggsave('Observed_spaghetti_groups.pdf')
scores_true = cbind.data.frame(as.vector(ALPHA[,1]), as.vector(ALPHA[,2]), Group, stringsAsFactors = FALSE)
colnames(scores_true ) = c('fpc1', 'fpc2', 'group')
ggplot(scores_true , aes(x=fpc1 , y=fpc2)) + geom_point() + aes(colour=factor(group))
ggsave('scatterplot_scores_truth.pdf')
pdf('fpcScores_true_scatterplots.pdf')
colors = rep('black', length(df$group))
colors[scores_true$group == 'G1'] = 'pink'
colors[scores_true$group == 'G2'] = 'green'
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,
xlab='FPC1 Score', ylab='FPC2 Score', col=colors,
main='True scores')
legend(x='topright', legend=c("G1", 'G2'),
col=c('pink', 'green'), pch=c(16,16), cex=0.8)
dev.off()
load('estimates_N100_Orth_G2.RData')
ALPHA_array = alpha_new
MU_array = theta_mu_new
THETA_array = Theta_new
phi_t_cont = results_basis$orth_spline_basis_cont
time_cont = results_basis$time_cont
N = prepared_data$num_subjects
MU_true = dat$params[[7]][(1+Q1):(Q+Q1)]
FPC_true = dat$params[[8]][, (1+K1):(K+K1)]
# re-run the following to make sure
time = Y = list()
ids=rep(1:N,each=1)
for (i in 1:N){
time[[i]] = dat$TIME_SPARSE[[1]][[i]][[J]]
Y[[i]] = dat$Y_SPARSE[[1]][[i]][[J]]
}
time_sparse = time # coming from wide format: sampling time point for each subject
Y_sparse = Y # coming from wide format: response for each subject
time_unique = dat$time
nloop=dim(ALPHA_array)[3]
first=1
last=nloop
pdf('plot_stan.pdf')
par(mfcol=c(2,2))
#plot mean functions
MU_mean=MU_array[, 1]
for(iter in 2:nloop){
MU_mean = MU_mean + MU_array[, iter]
}
MU_mean=cbind(MU_mean/(last-first+1))
Mu_true_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_true
Mu_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_mean
Mu1_true=Mu_true_functions[1:length(time_cont)] # referring to 1st block
Mu1=Mu_functions[1:length(time_cont)]
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4, xlab='Time', ylab='Response')
for(i in 1:N){
lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)
}
lines(time_cont,Mu1,type="l",col=2,lwd=2)
title('True vs. Estimated Mean')
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')
#plot PC functions
THETA_mean = THETA_array[,,first]
for(iter in 2:nloop){
THETA_mean = THETA_mean + THETA_array[,,iter]
}
THETA_mean=cbind(THETA_mean/(last-first+1))
FPC1_mean=t(phi_t_cont)%*%THETA_mean # for 1st block
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)), xlab='Time', ylab='Response')
lines(time_unique,FPC_true[,2],type="l",lwd=1)
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)
title(main="True vs. Estimated PFCs")
legend('topright', c('True', 'Estimated'), col=c(1, 2), lty=c(1,1), bty='n')
dev.off()
####### additional plots #########
load('estimates_N100_Orth_G2.RData')
K = npcs = 2  # revised manually; think about saving its value, also Q, earlier
ALPHA_array = alpha_new
MU_array = theta_mu_new
THETA_array = Theta_new
phi_t_cont = results_basis$orth_spline_basis_cont
phi_t = results_basis$orth_spline_basis_sparse
time_cont = results_basis$time_cont
nloop=dim(ALPHA_array)[3]
first=1
last=nloop
N = prepared_data$num_subjects
MU_mean = MU_array[, first] #mean function across sampling sessions
ALPHA_mean = ALPHA_array[,,first] # mean factor scores
THETA_mean = THETA_array[,,first] # mean factor loading
for(iter in 2:nloop){
MU_mean = MU_mean + MU_array[, iter]
ALPHA_mean = ALPHA_mean + ALPHA_array[,,iter]
THETA_mean = THETA_mean + THETA_array[,,iter]
}
MU_mean=cbind(MU_mean/(last-first+1))
ALPHA_mean=cbind(ALPHA_mean/(last-first+1))
THETA_mean=cbind(THETA_mean/(last-first+1))
Mu_functions = t(bdiag(cbind(phi_t_cont)))%*%MU_mean
FPC_mean=t(phi_t_cont)%*%THETA_mean
df = prepared_data$data
Y_sparse = list()
time_sparse = list()
scores = data.frame(t(ALPHA_mean))
names(scores)=c("fpc1","fpc2")
df$fpc1=0 # principle component scores
df$fpc2=0
i = 0
for (pid in unique(df$ID)){
i = i + 1
Y_sparse[[i]] = df$response[df$ID == pid]
time_sparse[[i]] = df$time[df$ID == pid]
df$fpc1[df$ID == pid] = scores[i, 1]
df$fpc2[df$ID == pid] = scores[i, 2]
}
Fits_sparse=list()
for(i in 1:N){
Fits_sparse[[i]] = t(phi_t[[i]]) %*% MU_mean + t(phi_t[[i]]) %*% THETA_mean %*% ALPHA_mean[, i]
}
pdf('mean_spaghetti.pdf')
plot(time_cont, Mu_functions, type="l", ylim=c(min(unlist(Y_sparse)),
max(unlist(Y_sparse))), xlim=c(0,1), ylab='Standardized Response', lwd=5, col=4)
for(i in 1:N){
lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)
}
title(main='Response')
dev.off()
pdf('spaghetti_smoothed.pdf')
par(mfrow=c(1,2))
plot(time_cont, Mu_functions,type="n", ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),
lwd=5, col=4, ylab='Standardized Response', xlab='Time')
for(i in 1:N){
lines(time_sparse[[i]], Y_sparse[[i]], type="l", lwd=.25)
}
title(main='Observed Response')
plot(time_cont, Mu_functions, type="n", ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),
lwd=2,col=4, ylab='Standardized Response', xlab='Time')
for(i in 1:N){
lines(time_sparse[[i]],Fits_sparse[[i]], type="l", lwd=.25)
}
title(main='Smoothed Response')
dev.off()
### spaghetti plots with mean curves for each group ###
df_more = df
df_more$Y_sparse = unlist(Y_sparse) # check: sum(df_more$Y_sparse != df_more$response) == 0
df_more$Fits_sparse = unlist(Fits_sparse)
library(ggplot2)
ggplot(df_more, aes(x=time, y=Fits_sparse)) + geom_line() + guides(colour=FALSE) +
xlab("Observation Time Point") + ylab("Smoothed Response") + aes(colour = factor(id)) +
facet_wrap(~ group) + # by different groups
geom_smooth(se=FALSE, colour="black", size=1) # add mean smooth line
ggsave('Smoothed_spaghetti_groups.pdf')
