########## generate simulated data with N=100 and Orth=TRUE #######
#
rm(list=ls())#
list.files()#
#
library(Matrix)#
set.seed(31)#
#
###############################
###############################
##  SIMULATION PARAMETERS   ###
###############################
###############################
#
source("simulate_data_sparse.R")#
source("basis_setup_sparse.R")#
#
T_min=0;T_max=1;T_range=c(T_min,T_max)#
N_T_max=10;N_T_mean=10#
P=2#
N=100#
nknots=c(1,2)#
params=list()#
orth=TRUE#
#
Q_true=c(2,2) # number of modes of variation (i.e. number of PCs)#
R_true=diag(rep(1,sum(Q_true)));R_true[1,4]=.75;R_true[4,1]=R_true[1,4] # correlation of FPCA scores#
D_true=diag(rep(1,sum(Q_true)));D_true[1,1]=2;D_true[3,3]=2; #D_true=0.1*D_true # standard deviations of FPCA scores#
SIGMA_ALPHA_true=D_true%*%R_true%*%D_true # Variance-covariance matrix of FPCA scores#
SIGMA_OMEGA_true=0.01*rep(1,P) # Error variances#
#MU_true=rep(0,sum(nknots+4)) # Coefficients of basis functions for mean curves across subjects#
#MU_true=c(c(1.8,.8,.4,.2,-1.2),c(-1.8,-.8,-.4,-.2,0,0))#
MU_true=c(c(1.8, .8, .4, .2, -1.2), #
		  c(0.125689927, 0.085802413, -0.107942359, -0.164469410, -0.009916578, -0.081660406))#
## set up FPC_true#
time=seq(T_range[1],T_range[2],(T_range[2]-T_range[1])/(N_T_max-1))#
time_sparse=list()#
for(i in 1:N){#
	time_sparse[[i]]=list()#
	for(p in 1:P){#
		time_sparse[[i]][[p]]=time#
	}#
}#
basis_stuff=basis_setup_sparse(time_sparse,nknots, orth=orth)#
knots=basis_stuff[[1]]#
time_sparse=basis_stuff[[2]]#
time_sparse_combined=basis_stuff[[3]]#
phi_t=basis_stuff[[4]]#
time_cont=basis_stuff[[5]]#
phi_t_cont=	basis_stuff[[6]]#
Phi_D=basis_stuff[[7]]#
Phi_D_T=basis_stuff[[8]]#
#
# FPCA loadings#
if(nknots[2]==1){#
	THETA_true=cbind(c(0.40529575,0.82201395,0.39930063,-0.02187301,-0.01044030,rep(0,5)),#
		c(0.06137363,0.10733627,-0.33973487,-0.81361591,-0.45532579,rep(0,5)),#
		c(rep(0,5),0.3490362,0.7295541,0.5036934,0.2608049,0.1555581),#
		c(rep(0,5),0.2280605,0.3930486,-0.2056171,-0.7682501,-0.4012662))#
}#
if(nknots[2]==2){#
	THETA_true=cbind(c(0.40529575,0.82201395,0.39930063,-0.02187301,-0.01044030,rep(0,6)),#
		c(0.06137363,0.10733627,-0.33973487,-0.81361591,-0.45532579,rep(0,6)),#
		# c(rep(0,5),0.3490362,0.7295541,0.5036934,0.2608049,0.1555581,.075),#
		# c(rep(0,5),0.2280605,0.3930486,-0.2056171,-0.7682501,-0.4012662,0))#
		c(rep(0,5), 0.1734486, 0.2471184, 0.5260293, 0.5316424, 0.4836753, 0.2758460),#
		c(rep(0,5), 0.79569747, 0.31964112, -0.16640001, -0.17366537, -0.04200097, -0.05197922))#
}#
#
FPC_true=array(0,dim=c(N_T_max,sum(Q_true)))#
for(t in 1:N_T_max){#
	ind=0#
	for(q in 1:length(Q_true)){#
		FPC_true[t,(ind+1):(ind+Q_true[q])]=(Phi_D[[1]][[t]]%*%THETA_true)[q,(ind+1):(ind+Q_true[q])]#
		ind=ind+Q_true[q]#
	}	#
}#
#
## Set up param list#
#
params[[1]]=nknots#
params[[2]]=Q_true#
params[[3]]=R_true#
params[[4]]=D_true#
params[[5]]=SIGMA_OMEGA_true#
params[[6]]=THETA_true#
params[[7]]=MU_true#
params[[8]]=FPC_true#
#
########################
########################
##   GENERATE DATA   ###
########################
########################
#
TIME_SPARSE=list()#
Y_SPARSE=list()#
MU_SPARSE=list()#
F_SPARSE=list()#
OMEGA_SPARSE=list()#
ALPHA=list()#
#
nsims=1#
for(ii in 1:nsims){#
    simdata=simulate_data_sparse(T_range=T_range,N_T_max=N_T_max,N_T_mean=N_T_mean,P,N,params,orth=orth)#
	TIME_SPARSE[[ii]]=simdata[[1]]#
	Y_SPARSE[[ii]]=simdata[[2]]#
	MU_SPARSE[[ii]]=simdata[[3]]#
	F_SPARSE[[ii]]=simdata[[4]]#
	OMEGA_SPARSE[[ii]]=simdata[[5]]#
	ALPHA[[ii]]=simdata[[6]]#
}#
#
phi_t = simdata[[9]]#
####### warning: need to be called the following name, otherwise need to change the default in mfpca.R#
save(file="sim_N100_Orth.RData",TIME_SPARSE,Y_SPARSE,MU_SPARSE,F_SPARSE,OMEGA_SPARSE,ALPHA,params,knots,time, phi_t)#
##############################
##############################
##  RUN MULTI-FPCA MODEL   ###
##############################
##############################
#
# rm(list=ls())#
#
source("mfpca.R") ## need to change the loaded simulation file in mfpca.R code#
load("sim_N100_Orth.RData")#
#
nsims=length(Y_SPARSE)#
sim_results=list()#
for(ii in 1:nsims){#
		Y_sparse=Y_SPARSE[[ii]]#
		time_sparse=TIME_SPARSE[[ii]]#
		N=length(Y_sparse)#
		group=rep(1,N)#
		Q=c(2,2)#
		nknots=c(1,2)#
		nloop=150#
		burnin=50#
		thin=10#
		orth=TRUE#
		sim=TRUE#
		sim_results[[ii]]=mfpca(Y_sparse=Y_sparse,time_sparse=time_sparse,#
			group=group,Q,nknots=nknots,nloop=nloop,burnin=burnin,thin=thin,orth=orth,sim=TRUE)#
}#
save.image(file="sim_results_N100_Orth.Rdata")#
#######################
#######################
##  CHECK RESULTS   ###
#######################
#######################
#
# rm(list=ls())#
load("sim_results_N100_Orth.Rdata")#
#
ALPHA_array=sim_results[[1]][[1]]#
MU_array=sim_results[[1]][[2]]#
D_array=sim_results[[1]][[3]]#
R_array=sim_results[[1]][[4]]#
SIGMA_OMEGA_array=sim_results[[1]][[5]]#
THETA_array=sim_results[[1]][[6]]#
basis_stuff=sim_results[[1]][[7]]#
knots=basis_stuff[[1]]#
time_sparse=basis_stuff[[2]]#
phi_t=basis_stuff[[3]]#
time_cont=basis_stuff[[4]]#
phi_t_cont=basis_stuff[[5]]#
params=sim_results[[1]][[8]]#
nknots=params[[1]]#
Q_true=params[[2]]#
R_true=params[[3]]#
D_true=params[[4]]#
SIGMA_OMEGA_true=params[[5]]#
THETA_true=params[[6]]#
MU_true=params[[7]]#
FPC_true=params[[8]]#
#
### start plotting#
#
nloop=length(ALPHA_array)#
first=1#
last=nloop#
#
#plot mean functions#
MU_mean=MU_array[[1]]#
for(iter in 2:nloop){#
	MU_mean=MU_mean+MU_array[[iter]]#
}#
MU_mean=cbind(MU_mean/(last-first+1))#
Mu_true_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_true#
Mu_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_mean#
Mu1_true=Mu_true_functions[1:length(time_cont)]#
Mu2_true=Mu_true_functions[(length(time_cont)+1):(2*length(time_cont))]#
Mu1=Mu_functions[1:length(time_cont)]#
Mu2=Mu_functions[(length(time_cont)+1):(2*length(time_cont))]#
#
pdf('plots_mfpca.pdf')#
### figure 1: mean curve on individual spagetti plots#
par(mfrow=c(2,2))#
#par(mfrow=c(1,2))#
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4)#
for(i in 1:N){#
	lines(time_sparse[[i]][[1]],Y_sparse[[i]][[1]],type="l",lwd=.25)#
}#
lines(time_cont,Mu1,type="l",col=1,lwd=2)#
#abline(a=0,b=0,col=4,lwd=1)#
title(main="Y1")#
plot(time_cont,Mu2_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4)#
for(i in 1:N){#
	lines(time_sparse[[i]][[2]],Y_sparse[[i]][[2]],type="l",lwd=.25)#
}#
lines(time_cont,Mu2,type="l",col=1,lwd=2)#
#abline(a=0,b=0,col=4,lwd=1)#
title(main="Y2")#
#### figure 2: plot FPC curves (dominant modes) #
THETA_mean=THETA_array[[first]]#
for(iter in 2:nloop){#
	THETA_mean=THETA_mean+THETA_array[[iter]]#
}#
THETA_mean=cbind(THETA_mean/(last-first+1))#
#
FPC1_mean=t(phi_t_cont[[1]])%*%THETA_mean[1:5,1:2]#
FPC2_mean=t(phi_t_cont[[2]])%*%THETA_mean[6:11,3:4]#
#
#par(mfrow=c(1,2))#
plot(time,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)))#
lines(time,FPC_true[,2],type="l",lwd=1)#
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)#
title(main="PFCs for Variable 1")#
plot(time,FPC_true[,3],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)))#
lines(time,FPC_true[,4],type="l",lwd=1)#
lines(time_cont,FPC2_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC2_mean[,2],type="l",lwd=1,col=2)#
title(main="PFCs for Variable 2")#
dev.off()
library(parallel)#
library(rstan)#
library(loo)#
library(Matrix)#
#
options(mc.cores = parallel::detectCores())#
source('../../../../sfpca.R')#
#
#### test on simulated code#
load("sim_N100_Orth.RData", dat <- new.env())#
#ls.str(dat) #
#
## true values of parameters#
J = 2#
N = length(dat$Y_SPARSE[[1]])#
nknots = dat$params[[1]][[J]] #
Q = nknots + 4 # number of basis#
K = dat$params[[2]][[J]] # number of PC#
sigma_eps = sqrt(dat$params[[5]][[J]]) # SIGMA_OMEGA_true is error variance#
#
Q1 = dat$params[[1]][[1]] + 4#
K1 = dat$params[[2]][[1]]#
#
Theta = dat$params[[6]][(1+Q1):(Q+Q1), (1+K1):(K+K1)] # THETA_true#
theta_mu = dat$params[[7]][(1+Q1):(Q+Q1)] # MU_true#
ALPHA = t(dat$ALPHA[[1]][(1+K1):(K+K1), ]) # ALPHA#
Group = ifelse(ALPHA[, 1] > -0.1, 'G1', 'G2') # 49 in G1 and 51 in G2#
table(Group)#
#
# basis#
phi_t = dat$phi_t[[J]]#
phi_t_stacked=NULL#
for(i in 1:N){#
	phi_t_stacked = rbind(phi_t_stacked, t(phi_t[[i]]))#
}#
## simulated data#
time = Y = MU = F = Omega = Alpha = list() #
ids=rep(1:N,each=1)#
#
for (i in 1:N){#
	time[[i]] = dat$TIME_SPARSE[[1]][[i]][[J]]#
	Y[[i]] = dat$Y_SPARSE[[1]][[i]][[J]]#
	MU[[i]] = dat$MU_SPARSE[[1]][[i]][[J]]#
	F[[i]] = dat$F_SPARSE[[1]][[i]][[J]]#
	Omega[[i]] = dat$OMEGA_SPARSE[[1]][[i]][[J]]#
}#
#
## convert data to data frame#
nrows = length(unlist(time))#
nvisits = sapply(time, length)#
df = data.frame(matrix(rep(0, nrows * 3), nrow=nrows))#
colnames(df) = c('id', 'time', 'response')#
for (j in 1:nrows){#
	df$id = rep(1:N, nvisits)#
	df$time = unlist(time)#
	df$response = unlist(Y)#
}#
#
# add group assigment#
id.list = unique(df$id)#
df$group = rep(0, nrows)#
for (i in 1:length(id.list)){#
	df$group[df$id == id.list[i]] = Group[i]#
}
prepared_data = prepare_data(data=df, unique_subject_id = 'id', time_var='time', response='response')#
results_basis = basis_setup_sparse(prepared_data=prepared_data, nknots=nknots, orth=TRUE)#
#
## check whether my generated basis is the same as the simulated one: should always be equal#
sum(results_basis$orth_spline_basis_sparse_stacked) == sum(phi_t_stacked) #
##################### run sfpca stan model ###############
Nsamples = 1000#
Nchains = 3#
#
model_file = "../../../../sfpca2.stan"#
smod = stan_model(model_file)#
#
pca_data <- list(N = prepared_data$num_subjects, K = K, Q = Q, Y = prepared_data$response.list,#
		             V = prepared_data$visits.vector, subject_starts = prepared_data$visits.start,#
			   	     subject_stops = prepared_data$visits.stop, cov_starts = prepared_data$cov.start,#
			   	     cov_stops = prepared_data$cov.stop,#
			   	     cov_size = prepared_data$cov.size, B = phi_t_stacked)#
set.seed(31)#
sa.list = sampling(smod, data= pca_data, iter=Nsamples, chains=Nchains,init="random")
sa = sa.list
Ynew = extract(sa,"Ynew",permuted=FALSE)#
V = prepared_data$visits.vector#
Ynew_transform = matrix(rep(0, Nsamples/2 * Nchains * sum(V)), ncol=sum(V))#
ind = 0#
for (i in 1:(Nsamples/2)){#
	for (j in 1:Nchains){#
		ind = ind + 1#
		Ynew_transform[ind, ] = Ynew[i,j,]#
	}#
}#
Ynew_mean = colMeans(Ynew_transform)
plot(dat$response, Ynew_mean)
plot(df$response, Ynew_mean)
library("bayesplot")#
library("ggplot2")#
color_scheme_set("brightblue")
pcc_dens_overlay(df$response, Ynew_transform[1:50, ])
ppc_dens_overlay(df$response, Ynew_transform[1:50, ])
pdf('predictive_cheking.pdf')
color_scheme_set("brightblue")
pcc_dens_overlay(df$response, Ynew_transform)
ppc_dens_overlay(df$response, Ynew_transform)
dev.off()
library(parallel)#
library(rstan)#
library(loo)#
library(Matrix)
load('estimates_N100_Orth_G2.RData')	#
#
ALPHA_array = alpha_new#
MU_array = theta_mu_new#
THETA_array = Theta_new#
phi_t_cont = results_basis$orth_spline_basis_cont#
time_cont = results_basis$time_cont#
N = prepared_data$num_subjects#
MU_true = dat$params[[7]][(1+Q1):(Q+Q1)]#
FPC_true = dat$params[[8]][, (1+K1):(K+K1)]#
#
# re-run the following to make sure#
time = Y = list() #
ids=rep(1:N,each=1)#
#
for (i in 1:N){#
	time[[i]] = dat$TIME_SPARSE[[1]][[i]][[J]]#
	Y[[i]] = dat$Y_SPARSE[[1]][[i]][[J]]#
}#
#
time_sparse = time # coming from wide format: sampling time point for each subject#
Y_sparse = Y # coming from wide format: response for each subject#
time_unique = dat$time#
nloop=dim(ALPHA_array)[3]#
first=1#
last=nloop#
#
pdf('plot_stan.pdf')#
par(mfcol=c(2,2))#
#plot mean functions#
MU_mean=MU_array[, 1]#
for(iter in 2:nloop){#
	MU_mean = MU_mean + MU_array[, iter]#
}#
MU_mean=cbind(MU_mean/(last-first+1))#
Mu_true_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_true#
Mu_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_mean#
Mu1_true=Mu_true_functions[1:length(time_cont)] # referring to 1st block#
Mu1=Mu_functions[1:length(time_cont)]#
#
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4, xlab='Time', ylab='Response')#
for(i in 1:N){#
	lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)#
}#
lines(time_cont,Mu1,type="l",col=2,lwd=2)#
title('True vs. Estimated Mean')#
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')#
#plot PC functions#
THETA_mean = THETA_array[,,first]#
for(iter in 2:nloop){#
	THETA_mean = THETA_mean + THETA_array[,,iter]#
}#
THETA_mean=cbind(THETA_mean/(last-first+1))#
#
FPC1_mean=t(phi_t_cont)%*%THETA_mean # for 1st block#
#
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)), xlab='Time', ylab='Response')#
lines(time_unique,FPC_true[,2],type="l",lwd=1)#
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)#
title(main="True vs. Estimated PFCs")#
legend('topright', c('True', 'Estimated'), col=c(1, 2), lty=c(1,1), bty='n')#
dev.off()#
####### additional plots ##########
load('estimates_N100_Orth_G2.RData')	#
K = npcs = 2  # revised manually; think about saving its value, also Q, earlier#
#
ALPHA_array = alpha_new#
MU_array = theta_mu_new#
THETA_array = Theta_new#
phi_t_cont = results_basis$orth_spline_basis_cont#
phi_t = results_basis$orth_spline_basis_sparse#
time_cont = results_basis$time_cont#
#
nloop=dim(ALPHA_array)[3]#
first=1#
last=nloop#
N = prepared_data$num_subjects#
MU_mean = MU_array[, first] #mean function across sampling sessions#
ALPHA_mean = ALPHA_array[,,first] # mean factor scores#
THETA_mean = THETA_array[,,first] # mean factor loading#
#
for(iter in 2:nloop){#
	MU_mean = MU_mean + MU_array[, iter]#
	ALPHA_mean = ALPHA_mean + ALPHA_array[,,iter]#
	THETA_mean = THETA_mean + THETA_array[,,iter]#
}#
#
MU_mean=cbind(MU_mean/(last-first+1))#
ALPHA_mean=cbind(ALPHA_mean/(last-first+1))#
THETA_mean=cbind(THETA_mean/(last-first+1))#
#
Mu_functions = t(bdiag(cbind(phi_t_cont)))%*%MU_mean#
FPC_mean=t(phi_t_cont)%*%THETA_mean#
#
df = prepared_data$data#
Y_sparse = list()#
time_sparse = list()#
scores = data.frame(t(ALPHA_mean)) #
names(scores)=c("fpc1","fpc2")#
df$fpc1=0 # principle component scores#
df$fpc2=0#
#
i = 0#
for (pid in unique(df$ID)){#
	i = i + 1#
	Y_sparse[[i]] = df$response[df$ID == pid]#
	time_sparse[[i]] = df$time[df$ID == pid]#
	df$fpc1[df$ID == pid] = scores[i, 1]#
	df$fpc2[df$ID == pid] = scores[i, 2]#
}#
#
Fits_sparse=list()#
for(i in 1:N){#
	Fits_sparse[[i]] = t(phi_t[[i]]) %*% MU_mean + t(phi_t[[i]]) %*% THETA_mean %*% ALPHA_mean[, i]#
}
plot(time_cont, FPC_mean[, 1], type="l", lwd=2, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),#
     xlab='Time', ylab='Value of PC Curve', cex.lab=1.5)#
lines(time_cont, FPC_mean[, 2],type="l",lwd=1, col='blue')#
title(main=paste("FPCs for", "Response"))#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('black', 'blue'), bty='n')
plot(time_cont, FPC_mean[, 1], type="l", lwd=2, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),#
     xlab='Time', ylab='Value of PC Curve', cex.lab=1.3, cex.axis = 1.2)#
lines(time_cont, FPC_mean[, 2],type="l",lwd=3, col='blue')#
title(main=paste("FPCs for", "Response"))#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('black', 'blue'), bty='n')
plot(time_cont, FPC_mean[, 1], type="l", lwd=3, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),#
     xlab='Time', ylab='Value of PC Curve', cex.lab=1.3, cex.axis = 1.2)#
lines(time_cont, FPC_mean[, 2],type="l",lwd=3, col='blue')#
title(main=paste("FPCs for", "Response"))#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('black', 'blue'), bty='n')
pdf('FPCs.pdf', width=5, height=5)#
plot(time_cont, FPC_mean[, 1], type="l", lwd=3, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),#
     xlab='Time', ylab='Value of PC Curve', cex.lab=1.3, cex.axis = 1.2)#
lines(time_cont, FPC_mean[, 2],type="l",lwd=3, col='blue')#
title(main=paste("FPCs for", "Response"))#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('black', 'blue'), bty='n')#
dev.off()
pdf('FPCs.pdf', width=7, height=5)#
plot(time_cont, FPC_mean[, 1], type="l", lwd=3, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),#
     xlab='Time', ylab='Value of PC Curve', cex.lab=1.3, cex.axis = 1.2)#
lines(time_cont, FPC_mean[, 2],type="l",lwd=3, col='blue')#
title(main=paste("FPCs for", "Response"))#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('black', 'blue'), bty='n')#
dev.off()
pdf('FPCs.pdf', width=6, height=5)#
plot(time_cont, FPC_mean[, 1], type="l", lwd=3, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),#
     xlab='Time', ylab='Value of PC Curve', cex.lab=1.3, cex.axis = 1.2)#
lines(time_cont, FPC_mean[, 2],type="l",lwd=3, col='blue')#
title(main=paste("FPCs for", "Response"))#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('black', 'blue'), bty='n')#
dev.off()
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='FPC1 Score', ylab='FPC2 Score', col=colors,#
     main='True scores', cex.lab=1.3, cex.axis = 1.2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16), cex=0.8)
options(mc.cores = parallel::detectCores())#
source('../../../../sfpca.R')#
#
#### test on simulated code#
load("sim_N100_Orth.RData", dat <- new.env())#
#ls.str(dat) #
#
## true values of parameters#
J = 2#
N = length(dat$Y_SPARSE[[1]])#
nknots = dat$params[[1]][[J]] #
Q = nknots + 4 # number of basis#
K = dat$params[[2]][[J]] # number of PC#
sigma_eps = sqrt(dat$params[[5]][[J]]) # SIGMA_OMEGA_true is error variance#
#
Q1 = dat$params[[1]][[1]] + 4#
K1 = dat$params[[2]][[1]]#
#
Theta = dat$params[[6]][(1+Q1):(Q+Q1), (1+K1):(K+K1)] # THETA_true#
theta_mu = dat$params[[7]][(1+Q1):(Q+Q1)] # MU_true#
ALPHA = t(dat$ALPHA[[1]][(1+K1):(K+K1), ]) # ALPHA#
Group = ifelse(ALPHA[, 1] > -0.1, 'G1', 'G2') # 49 in G1 and 51 in G2#
#
# basis#
phi_t = dat$phi_t[[J]]#
phi_t_stacked=NULL#
for(i in 1:N){#
	phi_t_stacked = rbind(phi_t_stacked, t(phi_t[[i]]))#
}#
## simulated data#
time = Y = MU = F = Omega = Alpha = list() #
ids=rep(1:N,each=1)#
#
for (i in 1:N){#
	time[[i]] = dat$TIME_SPARSE[[1]][[i]][[J]]#
	Y[[i]] = dat$Y_SPARSE[[1]][[i]][[J]]#
	MU[[i]] = dat$MU_SPARSE[[1]][[i]][[J]]#
	F[[i]] = dat$F_SPARSE[[1]][[i]][[J]]#
	Omega[[i]] = dat$OMEGA_SPARSE[[1]][[i]][[J]]#
}#
#
## convert data to data frame#
nrows = length(unlist(time))#
nvisits = sapply(time, length)#
df = data.frame(matrix(rep(0, nrows * 3), nrow=nrows))#
colnames(df) = c('id', 'time', 'response')#
for (j in 1:nrows){#
	df$id = rep(1:N, nvisits)#
	df$time = unlist(time)#
	df$response = unlist(Y)#
}#
#
# add group assigment#
id.list = unique(df$id)#
df$group = rep(0, nrows)#
for (i in 1:length(id.list)){#
	df$group[df$id == id.list[i]] = Group[i]#
}
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='FPC1 Score', ylab='FPC2 Score', col=colors,#
     main='True scores', cex.lab=1.3, cex.axis = 1.2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16), cex=0.8)
scores_true = cbind.data.frame(as.vector(ALPHA[,1]), as.vector(ALPHA[,2]), Group, stringsAsFactors = FALSE)#
colnames(scores_true ) = c('fpc1', 'fpc2', 'group')
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='FPC1 Score', ylab='FPC2 Score', col=colors,#
     main='True scores', cex.lab=1.3, cex.axis = 1.2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16), cex=0.8)
pdf('fpcScores_true_scatterplots.pdf')#
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='FPC1 Score', ylab='FPC2 Score', col=colors,#
     main='True scores', cex.lab=1.3, cex.axis = 1.2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16), cex=0.8)#
dev.off()
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='FPC1 Score', ylab='FPC2 Score', col=colors,#
     main='True scores', cex.lab=1.3, cex.axis = 1.2, font=2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16), cex=0.8)
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='FPC1 Score', ylab='FPC2 Score', col=colors,#
     main='True scores', cex.lab=1.3, , font=2, cex.axis = 1.2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16))
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='FPC1 Score', ylab='FPC2 Score', col=colors,#
     main='True scores', cex.lab=1.3, cex.axis = 1.2)#
mtext(font=2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16))
pdf('fpcScores_true_scatterplots.pdf')#
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='FPC1 Score', ylab='FPC2 Score', col=colors,#
     main='True scores', cex.lab=1.3, cex.axis = 1.2, font=2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16))#
dev.off()
pdf('FPCs.pdf', width=8, height=5)#
plot(time_cont, FPC_mean[, 1], type="l", lwd=3, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),#
     xlab='Time', ylab='Value of PC Curve', cex.lab=1.3, cex.axis = 1.2)#
lines(time_cont, FPC_mean[, 2],type="l",lwd=3, col='blue')#
title(main=paste("FPCs for", "Response"))#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('black', 'blue'), bty='n')#
dev.off()
pdf('FPCs.pdf', width=5, height=8)#
plot(time_cont, FPC_mean[, 1], type="l", lwd=3, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),#
     xlab='Time', ylab='Value of PC Curve', cex.lab=1.3, cex.axis = 1.2)#
lines(time_cont, FPC_mean[, 2],type="l",lwd=3, col='blue')#
title(main=paste("FPCs for", "Response"))#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('black', 'blue'), bty='n')#
dev.off()
par(mfcol=c(2,2))#
#plot mean functions#
MU_mean=MU_array[, 1]#
for(iter in 2:nloop){#
	MU_mean = MU_mean + MU_array[, iter]#
}#
MU_mean=cbind(MU_mean/(last-first+1))#
Mu_true_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_true#
Mu_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_mean#
Mu1_true=Mu_true_functions[1:length(time_cont)] # referring to 1st block#
Mu1=Mu_functions[1:length(time_cont)]#
#
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4, #
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2)#
for(i in 1:N){#
	lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)#
}#
lines(time_cont,Mu1,type="l",col=2,lwd=2)#
title('True vs. Estimated Mean')#
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')#
#plot PC functions#
THETA_mean = THETA_array[,,first]#
for(iter in 2:nloop){#
	THETA_mean = THETA_mean + THETA_array[,,iter]#
}#
THETA_mean=cbind(THETA_mean/(last-first+1))#
#
FPC1_mean=t(phi_t_cont)%*%THETA_mean # for 1st block#
#
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)),#
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2)#
lines(time_unique,FPC_true[,2],type="l",lwd=1)#
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)#
title(main="True vs. Estimated PFCs")#
legend('topright', c('True', 'Estimated'), col=c(1, 2), lty=c(1,1), bty='n')
load('estimates_N100_Orth_G2.RData')	#
#
ALPHA_array = alpha_new#
MU_array = theta_mu_new#
THETA_array = Theta_new#
phi_t_cont = results_basis$orth_spline_basis_cont#
time_cont = results_basis$time_cont#
N = prepared_data$num_subjects#
MU_true = dat$params[[7]][(1+Q1):(Q+Q1)]#
FPC_true = dat$params[[8]][, (1+K1):(K+K1)]#
#
# re-run the following to make sure#
time = Y = list() #
ids=rep(1:N,each=1)#
#
for (i in 1:N){#
	time[[i]] = dat$TIME_SPARSE[[1]][[i]][[J]]#
	Y[[i]] = dat$Y_SPARSE[[1]][[i]][[J]]#
}#
#
time_sparse = time # coming from wide format: sampling time point for each subject#
Y_sparse = Y # coming from wide format: response for each subject#
time_unique = dat$time#
nloop=dim(ALPHA_array)[3]#
first=1#
last=nloop#
#
pdf('plot_stan.pdf')#
par(mfcol=c(2,2))#
#plot mean functions#
MU_mean=MU_array[, 1]#
for(iter in 2:nloop){#
	MU_mean = MU_mean + MU_array[, iter]#
}#
MU_mean=cbind(MU_mean/(last-first+1))#
Mu_true_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_true#
Mu_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_mean#
Mu1_true=Mu_true_functions[1:length(time_cont)] # referring to 1st block#
Mu1=Mu_functions[1:length(time_cont)]#
#
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4, #
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2)#
for(i in 1:N){#
	lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)#
}#
lines(time_cont,Mu1,type="l",col=2,lwd=2)#
title('True vs. Estimated Mean')#
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')#
#plot PC functions#
THETA_mean = THETA_array[,,first]#
for(iter in 2:nloop){#
	THETA_mean = THETA_mean + THETA_array[,,iter]#
}#
THETA_mean=cbind(THETA_mean/(last-first+1))#
#
FPC1_mean=t(phi_t_cont)%*%THETA_mean # for 1st block#
#
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)),#
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2)#
lines(time_unique,FPC_true[,2],type="l",lwd=1)#
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)#
title(main="True vs. Estimated PFCs")#
legend('topright', c('True', 'Estimated'), col=c(1, 2), lty=c(1,1), bty='n')#
dev.off()
pdf('plot_stan.pdf')#
par(mfrow=c(2,2))#
#plot mean functions#
MU_mean=MU_array[, 1]#
for(iter in 2:nloop){#
	MU_mean = MU_mean + MU_array[, iter]#
}#
MU_mean=cbind(MU_mean/(last-first+1))#
Mu_true_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_true#
Mu_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_mean#
Mu1_true=Mu_true_functions[1:length(time_cont)] # referring to 1st block#
Mu1=Mu_functions[1:length(time_cont)]#
#
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4, #
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2)#
for(i in 1:N){#
	lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)#
}#
lines(time_cont,Mu1,type="l",col=2,lwd=2)#
title('True vs. Estimated Mean')#
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')#
#plot PC functions#
THETA_mean = THETA_array[,,first]#
for(iter in 2:nloop){#
	THETA_mean = THETA_mean + THETA_array[,,iter]#
}#
THETA_mean=cbind(THETA_mean/(last-first+1))#
#
FPC1_mean=t(phi_t_cont)%*%THETA_mean # for 1st block#
#
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)),#
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2)#
lines(time_unique,FPC_true[,2],type="l",lwd=1)#
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)#
title(main="True vs. Estimated PFCs")#
legend('topright', c('True', 'Estimated'), col=c(1, 2), lty=c(1,1), bty='n')#
dev.off()
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4, #
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2)#
for(i in 1:N){#
	lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)#
}#
lines(time_cont,Mu1,type="l",col=2,lwd=2)#
title('True vs. Estimated Mean')#
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')#
#plot PC functions#
THETA_mean = THETA_array[,,first]#
for(iter in 2:nloop){#
	THETA_mean = THETA_mean + THETA_array[,,iter]#
}#
THETA_mean=cbind(THETA_mean/(last-first+1))#
#
FPC1_mean=t(phi_t_cont)%*%THETA_mean # for 1st block#
#
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)),#
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2, font.lab=2 )#
lines(time_unique,FPC_true[,2],type="l",lwd=1)#
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)#
title(main="True vs. Estimated PFCs")#
legend('topright', c('True', 'Estimated'), col=c(1, 2), lty=c(1,1), bty='n')
pdf('plot_stan.pdf')#
par(mfrow=c(2,2))#
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4, #
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2, font.lab=2)#
for(i in 1:N){#
	lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)#
}#
lines(time_cont,Mu1,type="l",col=2,lwd=2)#
title('True vs. Estimated Mean')#
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')#
#plot PC functions#
THETA_mean = THETA_array[,,first]#
for(iter in 2:nloop){#
	THETA_mean = THETA_mean + THETA_array[,,iter]#
}#
THETA_mean=cbind(THETA_mean/(last-first+1))#
#
FPC1_mean=t(phi_t_cont)%*%THETA_mean # for 1st block#
#
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)),#
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2, font.lab=2)#
lines(time_unique,FPC_true[,2],type="l",lwd=1)#
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)#
title(main="True vs. Estimated PFCs")#
legend('topright', c('True', 'Estimated'), col=c(1, 2), lty=c(1,1), bty='n')#
dev.off()
pdf('FPCs.pdf', width=5, height=8)#
plot(time_cont, FPC_mean[, 1], type="l", lwd=3, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),#
     xlab='Time', ylab='Value of PC Curve', cex.lab=1.3, cex.axis = 1.2, font.lab=2)#
lines(time_cont, FPC_mean[, 2],type="l",lwd=3, col='blue')#
title(main=paste("FPCs for", "Response"))#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('black', 'blue'), bty='n')#
dev.off()
pdf('fpcScores_true_scatterplots.pdf')#
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='FPC1 Score', ylab='FPC2 Score', col=colors,#
     main='True scores', cex.lab=1.3, cex.axis = 1.2, font.lab=2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16))#
dev.off()
library(ggpubr)#
library(gridExtra)
ggboxplot(df, x = "group", y = "fpc1", color = "group")+ #
stat_compare_means(comparisons = my_comparisons, method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))
ggboxplot(df, x = "group", y = "fpc1", color = "group")+ #
stat_compare_means(method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))
head(df)
df = prepared_data$data#
Y_sparse = list()#
time_sparse = list()#
scores = data.frame(t(ALPHA_mean)) #
names(scores)=c("fpc1","fpc2")#
df$fpc1=0 # principle component scores#
df$fpc2=0#
#
i = 0#
for (pid in unique(df$ID)){#
	i = i + 1#
	Y_sparse[[i]] = df$response[df$ID == pid]#
	time_sparse[[i]] = df$time[df$ID == pid]#
	df$fpc1[df$ID == pid] = scores[i, 1]#
	df$fpc2[df$ID == pid] = scores[i, 2]#
}
head(df)
ggboxplot(df, x = "group", y = "fpc1", color = "group")+ #
stat_compare_means(method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))
library(ggpubr)#
library(gridExtra)#
pdf('fpcScores_ggBoxplot.pdf', width = 7, height = 4)#
### p-values based on T test (same as from simple linear regression)#
plot1 = ggboxplot(df, x = "group", y = "fpc1", color = "group")+ #
stat_compare_means(method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
#
plot2 = ggboxplot(df, x = "group", y = "fpc2",#
          color = "group", palette = colpal)+ #
stat_compare_means(method = "t.test") +#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
grid.arrange(plot1, plot2, ncol=2)#
dev.off()
library(ggpubr)#
library(gridExtra)#
pdf('fpcScores_ggBoxplot.pdf', width = 7, height = 4)#
### p-values based on T test (same as from simple linear regression)#
plot1 = ggboxplot(df, x = "group", y = "fpc1", color = "group")+ #
stat_compare_means(method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
#
plot2 = ggboxplot(df, x = "group", y = "fpc2", color = "group")+ #
stat_compare_means(method = "t.test") +#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
grid.arrange(plot1, plot2, ncol=2)#
dev.off()
plot1 = ggboxplot(df, x = "group", y = "fpc1", color = "group")+ #
stat_compare_means(aes(label = ..p.signif..), method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
#
plot2 = ggboxplot(df, x = "group", y = "fpc2", color = "group")+ #
stat_compare_means(aes(label = ..p.signif..), method = "t.test") +#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
grid.arrange(plot1, plot2, ncol=2)
plot1 = ggboxplot(df, x = "group", y = "fpc1", color = "group", add = "jitter")+ #
stat_compare_means(aes(label = ..p.signif..), method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
#
plot2 = ggboxplot(df, x = "group", y = "fpc2", color = "group", add = "jitter")+ #
stat_compare_means(aes(label = ..p.signif..), method = "t.test") +#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
grid.arrange(plot1, plot2, ncol=2)
pdf('fpcScores_ggBoxplot.pdf', width = 7, height = 4)#
### p-values based on T test (same as from simple linear regression)#
plot1 = ggboxplot(df, x = "group", y = "fpc1", color = "group")+ #
stat_compare_means(aes(label = ..p.signif..), method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
#
plot2 = ggboxplot(df, x = "group", y = "fpc2", color = "group")+ #
stat_compare_means(aes(label = ..p.signif..), method = "t.test") +#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
grid.arrange(plot1, plot2, ncol=2)#
dev.off()
table(df$group)
plot1 = ggboxplot(df, x = "group", y = "fpc1", color = "group", order=c('G1', 'G2'))+ #
stat_compare_means(aes(label = ..p.signif..), method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
#
plot2 = ggboxplot(df, x = "group", y = "fpc2", color = "group")+ #
stat_compare_means(aes(label = ..p.signif..), method = "t.test") +#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
grid.arrange(plot1, plot2, ncol=2)
plot1 = ggboxplot(df, x = "group", y = "fpc1", color = "group", order=c('G1', 'G2'))+ #
stat_compare_means(aes(label = ..p.signif..), label.x = 1.5, label.y = 40method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
#
plot2 = ggboxplot(df, x = "group", y = "fpc2", color = "group", order=c('G1', 'G2'))+ #
stat_compare_means(aes(label = ..p.signif..), label.x = 1.5, label.y = 40, method = "t.test") +#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
grid.arrange(plot1, plot2, ncol=2)
plot1 = ggboxplot(df, x = "group", y = "fpc1", color = "group", order=c('G1', 'G2'))+ #
stat_compare_means(aes(label = ..p.signif..), label.x = 1.5, label.y = 3, method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
#
plot2 = ggboxplot(df, x = "group", y = "fpc2", color = "group", order=c('G1', 'G2'))+ #
stat_compare_means(aes(label = ..p.signif..), label.x = 1.5, label.y = 1.5, method = "t.test") +#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
grid.arrange(plot1, plot2, ncol=2)
plot1 = ggboxplot(df, x = "group", y = "fpc1", color = "group", order=c('G1', 'G2'))+ #
stat_compare_means(aes(label = ..p.signif..), label.x = 1.5, label.y = 3, method = "t.test") + # Add pairwise comparisons p-value#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
#
plot2 = ggboxplot(df, x = "group", y = "fpc2", color = "group", order=c('G1', 'G2'))+ #
stat_compare_means(aes(label = ..p.signif..), label.x = 1.5, label.y = 2, method = "t.test") +#
theme(text = element_text(size=12), #
	  axis.title.x = element_text(size=18, face="bold"),#
      axis.title.y = element_text(size=18, face="bold"),#
      axis.text.x = element_text(face="bold", size=10),#
	  axis.text.y = element_text(face="bold", size=10))#
grid.arrange(plot1, plot2, ncol=2)
par(mfrow=c(1, 2))#
boxplot(fpc1 ~ group, data=df, main='Response (PC1)', ylab='FPC1 Score')#
boxplot(fpc2 ~ group, data=df, main='Response (PC2)', ylab='FPC2 Score')
pdf('fpcScores.pdf', width = 7, height = 4)#
par(mfrow=c(1, 2))#
boxplot(fpc1 ~ group, data=df, main='Response (PC1)', ylab='FPC1 Score', font.lab=2)#
boxplot(fpc2 ~ group, data=df, main='Response (PC2)', ylab='FPC2 Score', font.lab=2)#
dev.off()
par(mfrow=c(1, 2))#
boxplot(fpc1 ~ group, data=df, main='Response (PC1)', ylab='FPC1 Score')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
boxplot(fpc2 ~ group, data=df, main='Response (PC2)', ylab='FPC2 Score')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)
par(mfrow=c(1, 2))#
boxplot(fpc1 ~ group, data=df, main='Response (PC1)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
boxplot(fpc2 ~ group, data=df, main='Response (PC2)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)
pdf('fpcScores.pdf', width = 7, height = 4)#
par(mfrow=c(1, 2))#
boxplot(fpc1 ~ group, data=df, main='Response (PC1)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
boxplot(fpc2 ~ group, data=df, main='Response (PC2)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
dev.off()
pdf('fpcScores.pdf', width = 7, height = 4)#
par(mfrow=c(2, 1))#
boxplot(fpc1 ~ group, data=df, main='Response (PC1)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
boxplot(fpc2 ~ group, data=df, main='Response (PC2)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
dev.off()
pdf('fpcScores.pdf', width = 7, height = 4)#
par(mfrow=c(2, 2))#
boxplot(fpc1 ~ group, data=df, main='Response (PC1)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
boxplot(fpc2 ~ group, data=df, main='Response (PC2)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
dev.off()
pdf('fpcScores.pdf', width = 7, height = 6)#
par(mfrow=c(1, 2))#
boxplot(fpc1 ~ group, data=df, main='Response (PC1)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
boxplot(fpc2 ~ group, data=df, main='Response (PC2)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
dev.off()
pdf('plot_stan.pdf')#
par(mfcol=c(2,2))#
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4, #
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2, font.lab=2)#
for(i in 1:N){#
	lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)#
}#
lines(time_cont,Mu1,type="l",col=2,lwd=2)#
title('True vs. Estimated Mean')#
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)),#
	 xlab='Time', ylab='Response', cex.lab=1.3, cex.axis = 1.2, font.lab=2)#
lines(time_unique,FPC_true[,2],type="l",lwd=1)#
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)#
title(main="True vs. Estimated PFCs")#
legend('topright', c('True', 'Estimated'), col=c(1, 2), lty=c(1,1), bty='n')#
dev.off()
pdf('fpcScores.pdf')#
par(mfrow=c(2, 1))#
boxplot(fpc1 ~ group, data=df, main='Response (PC1)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
boxplot(fpc2 ~ group, data=df, main='Response (PC2)')#
title(ylab = "FPC score", xlab = "Groups", font.lab = 2)#
dev.off()
68 + 7 + 7 +26
11 + 7 + 8 + 6
24 + 12 + 5 + 17
rm(list=ls())#
list.files()#
#
library(Matrix)#
set.seed(31)#
#
###############################
###############################
##  SIMULATION PARAMETERS   ###
###############################
###############################
#
source("simulate_data_sparse.R")#
source("basis_setup_sparse.R")#
#
T_min=0;T_max=1;T_range=c(T_min,T_max)#
N_T_max=10;N_T_mean=10#
P=2#
N=100#
nknots=c(1,2)#
params=list()#
orth=TRUE#
#
Q_true=c(2,2) # number of modes of variation (i.e. number of PCs)#
R_true=diag(rep(1,sum(Q_true)));R_true[1,4]=.75;R_true[4,1]=R_true[1,4] # correlation of FPCA scores#
D_true=diag(rep(1,sum(Q_true)));D_true[1,1]=2;D_true[3,3]=2; #D_true=0.1*D_true # standard deviations of FPCA scores#
SIGMA_ALPHA_true=D_true%*%R_true%*%D_true # Variance-covariance matrix of FPCA scores#
SIGMA_OMEGA_true=0.01*rep(1,P) # Error variances#
#MU_true=rep(0,sum(nknots+4)) # Coefficients of basis functions for mean curves across subjects#
#MU_true=c(c(1.8,.8,.4,.2,-1.2),c(-1.8,-.8,-.4,-.2,0,0))#
MU_true=c(c(1.8, .8, .4, .2, -1.2), #
		  c(0.125689927, 0.085802413, -0.107942359, -0.164469410, -0.009916578, -0.081660406))#
## set up FPC_true#
time=seq(T_range[1],T_range[2],(T_range[2]-T_range[1])/(N_T_max-1))#
time_sparse=list()#
for(i in 1:N){#
	time_sparse[[i]]=list()#
	for(p in 1:P){#
		time_sparse[[i]][[p]]=time#
	}#
}#
basis_stuff=basis_setup_sparse(time_sparse,nknots, orth=orth)#
knots=basis_stuff[[1]]#
time_sparse=basis_stuff[[2]]#
time_sparse_combined=basis_stuff[[3]]#
phi_t=basis_stuff[[4]]#
time_cont=basis_stuff[[5]]#
phi_t_cont=	basis_stuff[[6]]#
Phi_D=basis_stuff[[7]]#
Phi_D_T=basis_stuff[[8]]#
#
# FPCA loadings#
if(nknots[2]==1){#
	THETA_true=cbind(c(0.40529575,0.82201395,0.39930063,-0.02187301,-0.01044030,rep(0,5)),#
		c(0.06137363,0.10733627,-0.33973487,-0.81361591,-0.45532579,rep(0,5)),#
		c(rep(0,5),0.3490362,0.7295541,0.5036934,0.2608049,0.1555581),#
		c(rep(0,5),0.2280605,0.3930486,-0.2056171,-0.7682501,-0.4012662))#
}#
if(nknots[2]==2){#
	THETA_true=cbind(c(0.40529575,0.82201395,0.39930063,-0.02187301,-0.01044030,rep(0,6)),#
		c(0.06137363,0.10733627,-0.33973487,-0.81361591,-0.45532579,rep(0,6)),#
		# c(rep(0,5),0.3490362,0.7295541,0.5036934,0.2608049,0.1555581,.075),#
		# c(rep(0,5),0.2280605,0.3930486,-0.2056171,-0.7682501,-0.4012662,0))#
		c(rep(0,5), 0.1734486, 0.2471184, 0.5260293, 0.5316424, 0.4836753, 0.2758460),#
		c(rep(0,5), 0.79569747, 0.31964112, -0.16640001, -0.17366537, -0.04200097, -0.05197922))#
}#
#
FPC_true=array(0,dim=c(N_T_max,sum(Q_true)))#
for(t in 1:N_T_max){#
	ind=0#
	for(q in 1:length(Q_true)){#
		FPC_true[t,(ind+1):(ind+Q_true[q])]=(Phi_D[[1]][[t]]%*%THETA_true)[q,(ind+1):(ind+Q_true[q])]#
		ind=ind+Q_true[q]#
	}	#
}
head(FPC_true)
dim(FPC_true)
plot(time, FPC_true[, 3], type="l", lwd=3, ylim=c(-1, 5),#
     xlab='time', ylab='PC Curve', cex.lab=1.2, font.lab=2, col='red')#
lines(time, FPC_true[, 4],type="l",lwd=3, col='blue')#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('red', 'blue'), bty='n')
pdf('FPCs_true.pdf', width=4, height=4)#
plot(time, FPC_true[, 3], type="l", lwd=3, ylim=c(-1, 5),#
     xlab='time', ylab='PC Curve', cex.lab=1.2, font.lab=2, col='red')#
lines(time, FPC_true[, 4],type="l",lwd=3, col='blue')#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('red', 'blue'), bty='n')#
dev.off()
MU_true
MU_true[6:11]
plot(time, MU_true[6:11], type="l", lwd=3, #
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')
time
Mu_functions = t(bdiag(cbind(phi_t_cont)))%*%MU_mean
Mu_functions = t(bdiag(cbind(phi_t_cont)))%*%MU_true
dim(MU_true)
MU_true
phi_t_cont
Phi_D
library(Matrix)#
Mu_functions = t(bdiag(cbind(phi_t_cont)))%*%MU_true
dim(t(bdiag(cbind(phi_t_cont))))
cbind(phi_t_cont)
dim(cbind(phi_t_cont))
dim(Phi_D_T)
dim(Phi_D)
Phi_D
library(Matrix)#
Mu_true_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_true
dim(t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]]))))
dim(MU_true)
length(MU_true)
dim(t(bdiag(cbind(phi_t_cont[[2]]))))
load("sim_results_N100_Orth.Rdata")#
#
ALPHA_array=sim_results[[1]][[1]]#
MU_array=sim_results[[1]][[2]]#
D_array=sim_results[[1]][[3]]#
R_array=sim_results[[1]][[4]]#
SIGMA_OMEGA_array=sim_results[[1]][[5]]#
THETA_array=sim_results[[1]][[6]]#
basis_stuff=sim_results[[1]][[7]]#
knots=basis_stuff[[1]]#
time_sparse=basis_stuff[[2]]#
phi_t=basis_stuff[[3]]#
time_cont=basis_stuff[[4]]#
phi_t_cont=basis_stuff[[5]]#
params=sim_results[[1]][[8]]#
nknots=params[[1]]#
Q_true=params[[2]]#
R_true=params[[3]]#
D_true=params[[4]]#
SIGMA_OMEGA_true=params[[5]]#
THETA_true=params[[6]]#
MU_true=params[[7]]#
FPC_true=params[[8]]
dim(t(bdiag(cbind(phi_t_cont[[2]]))))
plot(time, FPC_true[, 3], type="l", lwd=3, ylim=c(-1, 5),#
     xlab='time', ylab='PC Curve', cex.lab=1.2, font.lab=2, col='red')#
lines(time, FPC_true[, 4],type="l",lwd=3, col='blue')#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('red', 'blue'), bty='n')
plot(time, MU_true[6:11], type="l", lwd=3, #
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')
t(bdiag(cbind(phi_t_cont[[2]])))%*%MU_true[6:11]
plot(time, Mu_true_functions, type="l", lwd=3, #
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')
Mu_true_functions=t(bdiag(cbind(phi_t_cont[[2]])))%*%MU_true[6:11]
plot(time, Mu_true_functions, type="l", lwd=3, #
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')
time
Mu_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_mean#
Mu1_true=Mu_true_functions[1:length(time_cont)]#
#pdf('Mu_true.pdf', width=4, height=4)#
plot(time_cont, Mu1_true, type="l", lwd=3, #
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')
Mu_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_mean#
Mu1_true=Mu_true_functions[1:length(time_cont)]#
#pdf('Mu_true.pdf', width=4, height=4)#
plot(time_cont, Mu1_true, type="l", lwd=3, ylim=c(-1,1)#
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')
Mu_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_mean#
Mu1_true=Mu_true_functions[1:length(time_cont)]#
#pdf('Mu_true.pdf', width=4, height=4)#
plot(time_cont, Mu1_true, type="l", lwd=3, ylim=c(-1,1),#
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')
pdf('FPCs_true.pdf', width=4, height=4)#
plot(time, FPC_true[, 3], type="l", lwd=3, ylim=c(-1, 5),#
     xlab='time', ylab='PC Curve', cex.lab=1.2, font.lab=2, col='red')#
lines(time, FPC_true[, 4],type="l",lwd=3, col='blue')#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('red', 'blue'), bty='n')#
dev.off()#
#
Mu_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_mean#
Mu1_true=Mu_true_functions[1:length(time_cont)]#
pdf('Mu_true.pdf', width=4, height=4)#
plot(time_cont, Mu1_true, type="l", lwd=3, ylim=c(-5,5),#
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')#
dev.off()
Mu_true_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_true#
Mu1_true=Mu_true_functions[1:length(time_cont)]#
pdf('Mu_true.pdf', width=4, height=4)#
plot(time_cont, Mu1_true, type="l", lwd=3, ylim=c(-5,5),#
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')#
dev.off()
pdf('FPCs_true.pdf', width=4, height=4)#
plot(time, FPC_true[, 3], type="l", lwd=3, ylim=c(-1, 5),#
     xlab='time', ylab='PC Curve', cex.lab=1.2, font.lab=2, col='red')#
lines(time, FPC_true[, 4],type="l",lwd=3, col='blue')#
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('red', 'blue'), bty='n')#
dev.off()
plot(time_cont, Mu1_true, type="l", lwd=3, ylim=c(-10,10),#
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')
Mu_true_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_true#
Mu2_true=Mu_true_functions[(length(time_cont)+1):(2*length(time_cont))]#
pdf('Mu_true.pdf', width=4, height=4)#
plot(time_cont, Mu2_true, type="l", lwd=3, ylim=c(-10,10),#
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')#
dev.off()
Mu_true_functions=t(bdiag(cbind(phi_t_cont[[1]]),cbind(phi_t_cont[[2]])))%*%MU_true#
Mu2_true=Mu_true_functions[(length(time_cont)+1):(2*length(time_cont))]#
pdf('Mu_true.pdf', width=4, height=4)#
plot(time_cont, Mu2_true, type="l", lwd=3, ylim=c(-5,5),#
     xlab='time', ylab='Overall mean curve', cex.lab=1.2, font.lab=2, col='black')#
dev.off()
library(parallel)#
library(rstan)#
library(loo)#
library(Matrix)#
#
options(mc.cores = parallel::detectCores())#
source('../../../../sfpca.R')#
#
#### test on simulated code#
load("sim_N100_Orth.RData", dat <- new.env())#
#ls.str(dat) #
#
## true values of parameters#
J = 2#
N = length(dat$Y_SPARSE[[1]])#
nknots = dat$params[[1]][[J]] #
Q = nknots + 4 # number of basis#
K = dat$params[[2]][[J]] # number of PC#
sigma_eps = sqrt(dat$params[[5]][[J]]) # SIGMA_OMEGA_true is error variance#
#
Q1 = dat$params[[1]][[1]] + 4#
K1 = dat$params[[2]][[1]]#
#
Theta = dat$params[[6]][(1+Q1):(Q+Q1), (1+K1):(K+K1)] # THETA_true#
theta_mu = dat$params[[7]][(1+Q1):(Q+Q1)] # MU_true#
ALPHA = t(dat$ALPHA[[1]][(1+K1):(K+K1), ]) # ALPHA#
Group = ifelse(ALPHA[, 1] > -0.1, 'G1', 'G2') # 49 in G1 and 51 in G2#
table(Group)#
#
# basis#
phi_t = dat$phi_t[[J]]#
phi_t_stacked=NULL#
for(i in 1:N){#
	phi_t_stacked = rbind(phi_t_stacked, t(phi_t[[i]]))#
}#
## simulated data#
time = Y = MU = F = Omega = Alpha = list() #
ids=rep(1:N,each=1)#
#
for (i in 1:N){#
	time[[i]] = dat$TIME_SPARSE[[1]][[i]][[J]]#
	Y[[i]] = dat$Y_SPARSE[[1]][[i]][[J]]#
	MU[[i]] = dat$MU_SPARSE[[1]][[i]][[J]]#
	F[[i]] = dat$F_SPARSE[[1]][[i]][[J]]#
	Omega[[i]] = dat$OMEGA_SPARSE[[1]][[i]][[J]]#
}#
#
## convert data to data frame#
nrows = length(unlist(time))#
nvisits = sapply(time, length)#
df = data.frame(matrix(rep(0, nrows * 3), nrow=nrows))#
colnames(df) = c('id', 'time', 'response')#
for (j in 1:nrows){#
	df$id = rep(1:N, nvisits)#
	df$time = unlist(time)#
	df$response = unlist(Y)#
}#
#
# add group assigment#
id.list = unique(df$id)#
df$group = rep(0, nrows)#
for (i in 1:length(id.list)){#
	df$group[df$id == id.list[i]] = Group[i]#
}
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='PC1 score', ylab='PC2 score', col=colors,#
     main='True scores', font.lab=2, cex.lab=1.2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16), cex=0.8)
scores_true = cbind.data.frame(as.vector(ALPHA[,1]), as.vector(ALPHA[,2]), Group, stringsAsFactors = FALSE)#
colnames(scores_true ) = c('fpc1', 'fpc2', 'group')#
ggplot(scores_true , aes(x=fpc1 , y=fpc2)) + geom_point() + aes(colour=factor(group))
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='PC1 score', ylab='PC2 score', col=colors,#
     main='True scores', font.lab=2, cex.lab=1.2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16), cex=0.8)
pdf('fpcScores_true_scatterplots.pdf')#
colors = rep('black', length(df$group))   #
colors[scores_true$group == 'G1'] = 'pink'#
colors[scores_true$group == 'G2'] = 'green'#
plot(scores_true$fpc1, scores_true$fpc2, pch=20, cex=2,#
     xlab='PC1 score', ylab='PC2 score', col=colors,#
     main='True scores', font.lab=2, cex.lab=1.2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16), cex=0.8)#
dev.off()
getwd()
load('estimates_N100_Orth_G2.RData')	#
#
ALPHA_array = alpha_new#
MU_array = theta_mu_new#
THETA_array = Theta_new#
phi_t_cont = results_basis$orth_spline_basis_cont#
time_cont = results_basis$time_cont#
N = prepared_data$num_subjects#
MU_true = dat$params[[7]][(1+Q1):(Q+Q1)]#
FPC_true = dat$params[[8]][, (1+K1):(K+K1)]#
#
# re-run the following to make sure#
time = Y = list() #
ids=rep(1:N,each=1)#
#
for (i in 1:N){#
	time[[i]] = dat$TIME_SPARSE[[1]][[i]][[J]]#
	Y[[i]] = dat$Y_SPARSE[[1]][[i]][[J]]#
}#
#
time_sparse = time # coming from wide format: sampling time point for each subject#
Y_sparse = Y # coming from wide format: response for each subject#
time_unique = dat$time#
nloop=dim(ALPHA_array)[3]#
first=1#
last=nloop
par(mfcol=c(2,2))#
#plot mean functions#
MU_mean=MU_array[, 1]#
for(iter in 2:nloop){#
	MU_mean = MU_mean + MU_array[, iter]#
}#
MU_mean=cbind(MU_mean/(last-first+1))#
Mu_true_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_true#
Mu_functions=t(bdiag(cbind(phi_t_cont)))%*%MU_mean#
Mu1_true=Mu_true_functions[1:length(time_cont)] # referring to 1st block#
Mu1=Mu_functions[1:length(time_cont)]#
#
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10),xlim=c(0,1),lwd=2,col=4, xlab='Time', ylab='Response')#
for(i in 1:N){#
	lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)#
}#
lines(time_cont,Mu1,type="l",col=2,lwd=2)#
title('True vs. Estimated Mean')#
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')#
#plot PC functions#
THETA_mean = THETA_array[,,first]#
for(iter in 2:nloop){#
	THETA_mean = THETA_mean + THETA_array[,,iter]#
}#
THETA_mean=cbind(THETA_mean/(last-first+1))#
#
FPC1_mean=t(phi_t_cont)%*%THETA_mean # for 1st block#
#
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)), xlab='Time', ylab='Response')#
lines(time_unique,FPC_true[,2],type="l",lwd=1)#
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)#
title(main="True vs. Estimated PFCs")#
legend('topright', c('True', 'Estimated'), col=c(1, 2), lty=c(1,1), bty='n')
pdf('Mean_trueVsestimated.pdf', width = 4, height = 4)#
plot(time_cont,Mu1_true,type="l",ylim=c(-10,10), xlim=c(0,1),lwd=2,col=4, #
	 xlab='time', ylab='Response', font.lab=2, cex.lab=1.2)#
for(i in 1:N){#
	lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)#
}#
lines(time_cont,Mu1,type="l",col=2,lwd=2)#
#title('True vs. Estimated Mean')#
legend('topright', c('True', 'Estimated'), col=c(4, 2), lty=c(1,1), bty='n')#
dev.off()
pdf('FPCs_trueVsestimated.pdf', width = 4, height = 4)#
plot(time_unique,FPC_true[,1],type="l",lwd=2,ylim=c(min(FPC_true),max(FPC_true)), #
	 xlab='time', ylab='PC curve', font.lab=2, cex.lab=1.2)#
lines(time_unique,FPC_true[,2],type="l",lwd=1)#
lines(time_cont,FPC1_mean[,1],type="l",lwd=2,col=2)#
lines(time_cont,FPC1_mean[,2],type="l",lwd=1,col=2)#
#title(main="True vs. Estimated PFCs")#
legend('topright', c('True', 'Estimated'), col=c(1, 2), lty=c(1,1), bty='n')#
dev.off()
load('estimates_N100_Orth_G2.RData')	#
K = npcs = 2  # revised manually; think about saving its value, also Q, earlier#
#
ALPHA_array = alpha_new#
MU_array = theta_mu_new#
THETA_array = Theta_new#
phi_t_cont = results_basis$orth_spline_basis_cont#
phi_t = results_basis$orth_spline_basis_sparse#
time_cont = results_basis$time_cont#
#
nloop=dim(ALPHA_array)[3]#
first=1#
last=nloop#
N = prepared_data$num_subjects#
MU_mean = MU_array[, first] #mean function across sampling sessions#
ALPHA_mean = ALPHA_array[,,first] # mean factor scores#
THETA_mean = THETA_array[,,first] # mean factor loading#
#
for(iter in 2:nloop){#
	MU_mean = MU_mean + MU_array[, iter]#
	ALPHA_mean = ALPHA_mean + ALPHA_array[,,iter]#
	THETA_mean = THETA_mean + THETA_array[,,iter]#
}#
#
MU_mean=cbind(MU_mean/(last-first+1))#
ALPHA_mean=cbind(ALPHA_mean/(last-first+1))#
THETA_mean=cbind(THETA_mean/(last-first+1))#
#
Mu_functions = t(bdiag(cbind(phi_t_cont)))%*%MU_mean#
FPC_mean=t(phi_t_cont)%*%THETA_mean#
#
df = prepared_data$data#
Y_sparse = list()#
time_sparse = list()#
scores = data.frame(t(ALPHA_mean)) #
names(scores)=c("fpc1","fpc2")#
df$fpc1=0 # principle component scores#
df$fpc2=0#
#
i = 0#
for (pid in unique(df$ID)){#
	i = i + 1#
	Y_sparse[[i]] = df$response[df$ID == pid]#
	time_sparse[[i]] = df$time[df$ID == pid]#
	df$fpc1[df$ID == pid] = scores[i, 1]#
	df$fpc2[df$ID == pid] = scores[i, 2]#
}#
#
Fits_sparse=list()#
for(i in 1:N){#
	Fits_sparse[[i]] = t(phi_t[[i]]) %*% MU_mean + t(phi_t[[i]]) %*% THETA_mean %*% ALPHA_mean[, i]#
}
df_more = df#
df_more$Y_sparse = unlist(Y_sparse) # check: sum(df_more$Y_sparse != df_more$response) == 0#
df_more$Fits_sparse = unlist(Fits_sparse)
colors = rep('black', length(df$group))   #
colors[df$group == 'G1'] = 'pink'#
colors[df$group == 'G2'] = 'green'#
plot(df$fpc1, df$fpc2, pch=20, cex=2,#
     xlab='FPC1 Score', ylab='FPC2 Score', col=colors,#
     main='Response')#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16), cex=0.8)
par(mfrow=c(1, 2))#
boxplot(fpc1 ~ group, data=df, main='Response (PC1)', ylab='FPC1 Score')#
boxplot(fpc2 ~ group, data=df, main='Response (PC2)', ylab='FPC2 Score')
pdf('fpcScores_scatterplots.pdf', width=4, height=4)#
colors = rep('black', length(df$group))   #
colors[df$group == 'G1'] = 'pink'#
colors[df$group == 'G2'] = 'green'#
plot(df$fpc1, df$fpc2, pch=20, cex=2,#
     xlab='PC1 score', ylab='PC2 score', col=colors,#
     font.lab=2, cex.lab=1.2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(16,16), cex=0.8)#
dev.off()
pdf('fpcScores_scatterplots.pdf', width=4, height=4)#
colors = rep('black', length(df$group))   #
colors[df$group == 'G1'] = 'pink'#
colors[df$group == 'G2'] = 'green'#
plot(df$fpc1, df$fpc2, cex=2,#
     xlab='PC1 score', ylab='PC2 score', col=colors,#
     font.lab=2, cex.lab=1.2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), cex=0.8)#
dev.off()
pdf('fpcScores_scatterplots.pdf', width=4, height=4)#
colors = rep('black', length(df$group))   #
colors[df$group == 'G1'] = 'pink'#
colors[df$group == 'G2'] = 'green'#
plot(df$fpc1, df$fpc2, pch=20, cex=1,#
     xlab='PC1 score', ylab='PC2 score', col=colors,#
     font.lab=2, cex.lab=1.2)#
legend(x='topright', legend=c("G1", 'G2'), #
       col=c('pink', 'green'), pch=c(20,20), cex=0.8)#
dev.off()
