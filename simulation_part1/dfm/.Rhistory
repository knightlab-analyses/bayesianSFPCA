dat = dat[, c('X.SampleID', 'subject', 'timepoint', 'shannon_alpha', 'sample_site', 'sex')]
dat$timepoint = sub("^\\S+\\s+", '', dat$timepoint)
dat = dat[complete.cases(dat$shannon_alpha), ] # complete response (PD and shannon share same missing index)
dat = dat[!(dat$subject %in% c('Blank', 'swab blank', 'Swab blank', 'Beauty product', 'Skin')), ]
dim(dat) # 1560 * 6
## new unique ID
dat$ID_unique = paste(dat$subject, dat$sample_site, sep='')
## take average of duplicated alpha diversity
dat$shannon_avg = rep(0, dim(dat)[1])
pid_list = unique(dat$ID_unique)
sub = NULL
time_sampling = unique(dat$timepoint)
for (i in pid_list){
for (t in time_sampling){
idx = which(dat$ID_unique %in% i & dat$timepoint %in% t)
dat$shannon_avg[idx] = rep(mean(dat$shannon_alpha[idx]), length(idx))
sub = rbind(sub, dat[idx[1], ])
}
}
sub = sub[complete.cases(sub$shannon_avg), ] # not al
setwd("~/Study/thesis/Bayesian/sfpca/Knights_sim/dfm")
load("post_rotation_results.RData")
vars_select = c('ID', 'patient', 'time', 'response', 'Version') # selected variables from prepared_data$data
ALPHA_array = alpha_new
MU_array = theta_mu_new
THETA_array = Theta_new
phi_t_cont = results_basis$orth_spline_basis_cont
phi_t = results_basis$orth_spline_basis_sparse
time_cont = results_basis$time_cont
nloop=dim(ALPHA_array)[3]
first=1
last=nloop
# N = prepared_data$num_subjects
MU_mean = MU_array[, first] #mean function across sampling sessions
ALPHA_mean = ALPHA_array[,,first] # mean factor scores
THETA_mean = THETA_array[,,first] # mean factor loading
for(iter in 2:nloop){
MU_mean = MU_mean + MU_array[, iter]
ALPHA_mean = ALPHA_mean + ALPHA_array[,,iter]
THETA_mean = THETA_mean + THETA_array[,,iter]
}
MU_mean=cbind(MU_mean/(last-first+1))
ALPHA_mean=cbind(ALPHA_mean/(last-first+1))
THETA_mean=cbind(THETA_mean/(last-first+1))
Mu_functions = t(bdiag(cbind(phi_t_cont)))%*%MU_mean
FPC_mean=t(phi_t_cont)%*%THETA_mean
### create data frame containing needed information ####
df = prepared_data$data[, vars_select]
Y_sparse = list()
time_sparse = list()
scores = data.frame(t(ALPHA_mean))
names(scores)=c("fpc1","fpc2")
df$fpc1=0 # principle component scores
df$fpc2=0
i = 0
for (pid in unique(df$ID)){
i = i + 1
Y_sparse[[i]] = df$response[df$ID == pid]
time_sparse[[i]] = df$time[df$ID == pid]
df$fpc1[df$ID == pid] = scores[i, 1]
df$fpc2[df$ID == pid] = scores[i, 2]
}
Fits_sparse=list()
for(i in 1:N){
Fits_sparse[[i]] = t(phi_t[[i]]) %*% MU_mean + t(phi_t[[i]]) %*% THETA_mean %*% ALPHA_mean[, i]
}
df$Y_sparse = unlist(Y_sparse) # check: sum(df$Y_sparse != df$response) == 0
df$Fits_sparse = unlist(Fits_sparse)
df$residuals = df$Y_sparse - df$Fits_sparse
df$residuals = df$Y_sparse - df$Fits_sparse
library(ggplot2)
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
ggplot(df, aes(x=time*22, y=Fits_sparse, color=Version)) + geom_point(alpha=0) + # use alpha=0
xlab("Observation Time Point") + ylab("Smoothed Response") + scale_color_manual(values=colpal)+
theme_classic() + theme(axis.text = element_text(color='black')) +
geom_smooth(se=FALSE, size=1, aes(group=Version)) +
geom_point(data=df, aes(x=time, y=response, color=Version), alpha=0.5, size=1.2)
# theme(legend.position='top') +
ggsave('Smoothed_spaghetti_groups.pdf', width = 4, height = 3, dpi=600)
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
ggplot(df, aes(x=time*22, y=Fits_sparse, color=Version)) + geom_point(alpha=0) + # use alpha=0
xlab("Observation Time Point") + ylab("Smoothed Response") + scale_color_manual(values=colpal)+
theme_classic() + theme(axis.text = element_text(color='black')) +
geom_smooth(se=FALSE, size=1, aes(group=Version)) +
geom_point(data=df, aes(x=time*22, y=response, color=Version), alpha=0.5, size=1.2)
# theme(legend.position='top') +
ggsave('Smoothed_spaghetti_groups.pdf', width = 4, height = 3, dpi=600)
looic.obj = compare(looic.list[[1]],looic.list[[2]],looic.list[[3]], looic.list[[4]])
print(looic.obj)
library(rstan)
looic.obj = compare(looic.list[[1]],looic.list[[2]],looic.list[[3]], looic.list[[4]])
print(looic.obj)
load('stan_results.RData')
looic.obj = compare(looic.list[[1]],looic.list[[2]],looic.list[[3]], looic.list[[4]])
print(looic.obj)
library(rstan)
library(loo)
load('stan_results.RData')
looic.obj = compare(looic.list[[1]],looic.list[[2]],looic.list[[3]], looic.list[[4]])
print(looic.obj)
getwd()
looic.list[[3]]
looic.list[[4]]
sa = sa.list[[3]]
Ynew = extract(sa,"Ynew",permuted=FALSE)
V = prepared_data$visits.vector
Ynew_transform = matrix(rep(0, Nsamples/2 * Nchains * sum(V)), ncol=sum(V))
ind = 0
for (i in 1:(Nsamples/2)){
for (j in 1:Nchains){
ind = ind + 1
Ynew_transform[ind, ] = Ynew[i,j,]
}
}
Ynew_mean = colMeans(Ynew_transform)
pdf('predictive_checking.pdf')
library("bayesplot")
library("ggplot2")
color_scheme_set("brightblue")
ppc_dens_overlay(prepared_data$data$response, Ynew_transform)
dev.off()
i = 3; k = npcs =2; d = nknots =1;
sa = sa.list[[i]]
source('../../sfpca.R')
results_basis = basis_setup_sparse(prepared_data=prepared_data, nknots=d, orth=TRUE)
Sigma = extract(sa,"Sigma",permuted=FALSE)
W = extract(sa,"W",permuted=FALSE)
sigma_eps = extract(sa,"sigma_eps",permuted=FALSE)
theta_mu = extract(sa,"theta_mu",permuted=FALSE)
alpha = extract(sa,"alpha",permuted=FALSE)
Theta = extract(sa,"Theta",permuted=FALSE)
## Reshape parameters and reorient loadings with PCA rotation
N = prepared_data$num_subjects
K = npcs
Q = nknots + 4
theta_mu_new = array(0, dim=c(Q, Nchains*Nsamples/2))
alpha_old = alpha_new = array(0, dim=c(K, N, Nchains*Nsamples/2))
Theta_old = Theta_new = array(0, dim=c(Q, K, Nchains*Nsamples/2))
W_old = array(0, dim=c(Q, Q, Nchains*Nsamples/2))
ind = 0
for(i in 1:dim(W)[1]){
for(j in 1:dim(W)[2]){
ind = ind + 1
theta_mu_new[,ind] = array(theta_mu[i,j,])
alpha_old[,,ind] = t(array(alpha[i,j,],dim=c(N, K)))
Theta_old[,,ind] = array(Theta[i,j,],dim=c(Q, K))
W_old[,,ind] = array(W[i,j,],dim=c(Q,Q))
eigen_temp_sigma=eigen(W_old[,,ind])
v_temp=eigen_temp_sigma$vectors
d_temp=eigen_temp_sigma$values
for(com in 1:length(d_temp)){
if(!(d_temp[com]-Re(d_temp[com])==0)){
d_temp[com]=-1*10^5
}
}
pos_temp=array(0,dim=c(K,1))
for(pos in 1:K){
pos_temp[pos]=(1:length(d_temp))[max(d_temp)==d_temp]
d_temp[pos_temp[pos]]=-1e+5
}
Theta_new[,,ind]=v_temp[,pos_temp]
for(k in 1:K){
Theta_new[, k, ind]=sign(Theta_new[1,k,ind]) * Theta_new[,k,ind]
}
alpha_new[,, ind] = t(Theta_new[,,ind]) %*% Theta_old[,,ind] %*% alpha_old[,,ind]
}
}
save(N, K, Q, alpha_new, theta_mu_new, Theta_new, results_basis, prepared_data,
file="post_rotation_results.RData")
######### plotting ######
load("post_rotation_results.RData")
vars_select = c('ID', 'patient', 'time', 'response', 'Version') # selected variables from prepared_data$data
ALPHA_array = alpha_new
MU_array = theta_mu_new
THETA_array = Theta_new
phi_t_cont = results_basis$orth_spline_basis_cont
phi_t = results_basis$orth_spline_basis_sparse
time_cont = results_basis$time_cont
nloop=dim(ALPHA_array)[3]
first=1
last=nloop
# N = prepared_data$num_subjects
MU_mean = MU_array[, first] #mean function across sampling sessions
ALPHA_mean = ALPHA_array[,,first] # mean factor scores
THETA_mean = THETA_array[,,first] # mean factor loading
for(iter in 2:nloop){
MU_mean = MU_mean + MU_array[, iter]
ALPHA_mean = ALPHA_mean + ALPHA_array[,,iter]
THETA_mean = THETA_mean + THETA_array[,,iter]
}
MU_mean=cbind(MU_mean/(last-first+1))
ALPHA_mean=cbind(ALPHA_mean/(last-first+1))
THETA_mean=cbind(THETA_mean/(last-first+1))
Mu_functions = t(bdiag(cbind(phi_t_cont)))%*%MU_mean
FPC_mean=t(phi_t_cont)%*%THETA_mean
### create data frame containing needed information ####
df = prepared_data$data[, vars_select]
Y_sparse = list()
time_sparse = list()
scores = data.frame(t(ALPHA_mean))
names(scores)=c("fpc1","fpc2")
df$fpc1=0 # principle component scores
df$fpc2=0
i = 0
for (pid in unique(df$ID)){
i = i + 1
Y_sparse[[i]] = df$response[df$ID == pid]
time_sparse[[i]] = df$time[df$ID == pid]
df$fpc1[df$ID == pid] = scores[i, 1]
df$fpc2[df$ID == pid] = scores[i, 2]
}
Fits_sparse=list()
for(i in 1:N){
Fits_sparse[[i]] = t(phi_t[[i]]) %*% MU_mean + t(phi_t[[i]]) %*% THETA_mean %*% ALPHA_mean[, i]
}
df$Y_sparse = unlist(Y_sparse) # check: sum(df$Y_sparse != df$response) == 0
df$Fits_sparse = unlist(Fits_sparse)
df$residuals = df$Y_sparse - df$Fits_sparse
df$residuals = df$Y_sparse - df$Fits_sparse
write.table(df, 'data_sfpca.txt', sep='\t', row.names=F)
## residual analysis ##
pdf('residual_plots.pdf')
par(mfrow=c(1,2))
plot(df$residuals)
library(car); qqPlot(df$residuals)
dev.off()
pdf('mean_spaghetti.pdf')
plot(time_cont, Mu_functions, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))), ylab='pH', xlab='time', lwd=5, col=4)
for(i in 1:N){
lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)
}
title(main='pH')
dev.off()
pdf('spaghetti_smoothed.pdf')
par(mfrow=c(1,2))
plot(time_cont, Mu_functions,type="n", ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),
lwd=5, col=4, ylab='pH', xlab='Time')
for(i in 1:N){
lines(time_sparse[[i]], Y_sparse[[i]], type="l", lwd=.25)
}
title(main='Observed pH')
plot(time_cont, Mu_functions, type="n", ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),
lwd=2,col=4, ylab='pH', xlab='Time')
for(i in 1:N){
lines(time_sparse[[i]],Fits_sparse[[i]], type="l", lwd=.25)
}
title(main='Smoothed pH')
dev.off()
load("post_rotation_results.RData")
vars_select = c('ID', 'patient', 'time', 'response', 'Version') # selected variables from prepared_data$data
ALPHA_array = alpha_new
MU_array = theta_mu_new
THETA_array = Theta_new
phi_t_cont = results_basis$orth_spline_basis_cont
phi_t = results_basis$orth_spline_basis_sparse
time_cont = results_basis$time_cont
nloop=dim(ALPHA_array)[3]
first=1
last=nloop
# N = prepared_data$num_subjects
MU_mean = MU_array[, first] #mean function across sampling sessions
ALPHA_mean = ALPHA_array[,,first] # mean factor scores
THETA_mean = THETA_array[,,first] # mean factor loading
for(iter in 2:nloop){
MU_mean = MU_mean + MU_array[, iter]
ALPHA_mean = ALPHA_mean + ALPHA_array[,,iter]
THETA_mean = THETA_mean + THETA_array[,,iter]
}
MU_mean=cbind(MU_mean/(last-first+1))
ALPHA_mean=cbind(ALPHA_mean/(last-first+1))
THETA_mean=cbind(THETA_mean/(last-first+1))
Mu_functions = t(bdiag(cbind(phi_t_cont)))%*%MU_mean
FPC_mean=t(phi_t_cont)%*%THETA_mean
### create data frame containing needed information ####
df = prepared_data$data[, vars_select]
Y_sparse = list()
time_sparse = list()
scores = data.frame(t(ALPHA_mean))
names(scores)=c("fpc1","fpc2")
df$fpc1=0 # principle component scores
df$fpc2=0
i = 0
for (pid in unique(df$ID)){
i = i + 1
Y_sparse[[i]] = df$response[df$ID == pid]
time_sparse[[i]] = df$time[df$ID == pid]
df$fpc1[df$ID == pid] = scores[i, 1]
df$fpc2[df$ID == pid] = scores[i, 2]
}
Fits_sparse=list()
for(i in 1:N){
Fits_sparse[[i]] = t(phi_t[[i]]) %*% MU_mean + t(phi_t[[i]]) %*% THETA_mean %*% ALPHA_mean[, i]
}
df$Y_sparse = unlist(Y_sparse) # check: sum(df$Y_sparse != df$response) == 0
df$Fits_sparse = unlist(Fits_sparse)
df$residuals = df$Y_sparse - df$Fits_sparse
df$residuals = df$Y_sparse - df$Fits_sparse
library(parallel)
library(rstan)
library(loo) # for waic()
library(Matrix) # for bdiag(): construct a block diagnoal matrix
options(mc.cores = parallel::detectCores())
load("post_rotation_results.RData")
vars_select = c('ID', 'patient', 'time', 'response', 'Version') # selected variables from prepared_data$data
ALPHA_array = alpha_new
MU_array = theta_mu_new
THETA_array = Theta_new
phi_t_cont = results_basis$orth_spline_basis_cont
phi_t = results_basis$orth_spline_basis_sparse
time_cont = results_basis$time_cont
nloop=dim(ALPHA_array)[3]
first=1
last=nloop
# N = prepared_data$num_subjects
MU_mean = MU_array[, first] #mean function across sampling sessions
ALPHA_mean = ALPHA_array[,,first] # mean factor scores
THETA_mean = THETA_array[,,first] # mean factor loading
for(iter in 2:nloop){
MU_mean = MU_mean + MU_array[, iter]
ALPHA_mean = ALPHA_mean + ALPHA_array[,,iter]
THETA_mean = THETA_mean + THETA_array[,,iter]
}
MU_mean=cbind(MU_mean/(last-first+1))
ALPHA_mean=cbind(ALPHA_mean/(last-first+1))
THETA_mean=cbind(THETA_mean/(last-first+1))
Mu_functions = t(bdiag(cbind(phi_t_cont)))%*%MU_mean
FPC_mean=t(phi_t_cont)%*%THETA_mean
### create data frame containing needed information ####
df = prepared_data$data[, vars_select]
Y_sparse = list()
time_sparse = list()
scores = data.frame(t(ALPHA_mean))
names(scores)=c("fpc1","fpc2")
df$fpc1=0 # principle component scores
df$fpc2=0
i = 0
for (pid in unique(df$ID)){
i = i + 1
Y_sparse[[i]] = df$response[df$ID == pid]
time_sparse[[i]] = df$time[df$ID == pid]
df$fpc1[df$ID == pid] = scores[i, 1]
df$fpc2[df$ID == pid] = scores[i, 2]
}
Fits_sparse=list()
for(i in 1:N){
Fits_sparse[[i]] = t(phi_t[[i]]) %*% MU_mean + t(phi_t[[i]]) %*% THETA_mean %*% ALPHA_mean[, i]
}
df$Y_sparse = unlist(Y_sparse) # check: sum(df$Y_sparse != df$response) == 0
df$Fits_sparse = unlist(Fits_sparse)
df$residuals = df$Y_sparse - df$Fits_sparse
df$residuals = df$Y_sparse - df$Fits_sparse
write.table(df, 'data_sfpca.txt', sep='\t', row.names=F)
## residual analysis ##
pdf('residual_plots.pdf')
par(mfrow=c(1,2))
plot(df$residuals)
library(car); qqPlot(df$residuals)
dev.off()
###### start plotting ######
pdf('mean_spaghetti.pdf')
plot(time_cont, Mu_functions, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))), ylab='pH', xlab='time', lwd=5, col=4)
for(i in 1:N){
lines(time_sparse[[i]],Y_sparse[[i]],type="l",lwd=.25)
}
title(main='pH')
dev.off()
pdf('spaghetti_smoothed.pdf')
par(mfrow=c(1,2))
plot(time_cont, Mu_functions,type="n", ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),
lwd=5, col=4, ylab='pH', xlab='Time')
for(i in 1:N){
lines(time_sparse[[i]], Y_sparse[[i]], type="l", lwd=.25)
}
title(main='Observed pH')
plot(time_cont, Mu_functions, type="n", ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),
lwd=2,col=4, ylab='pH', xlab='Time')
for(i in 1:N){
lines(time_sparse[[i]],Fits_sparse[[i]], type="l", lwd=.25)
}
title(main='Smoothed pH')
dev.off()
library(ggplot2)
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
ggplot(df, aes(x=time*22, y=Fits_sparse, color=Version)) + geom_point(alpha=0) + # use alpha=0
xlab("Observation Time Point") + ylab("Smoothed Response") + scale_color_manual(values=colpal)+
theme_classic() + theme(axis.text = element_text(color='black')) +
geom_smooth(se=FALSE, size=1, aes(group=Version)) +
geom_point(data=df, aes(x=time*22, y=response, color=Version), alpha=0.5, size=1.2)
library(ggplot2)
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
ggplot(df, aes(x=time*22, y=Fits_sparse, color=Version)) + geom_point(alpha=0) + # use alpha=0
xlab("Observation Time Point") + ylab("Smoothed Response") + scale_color_manual(values=colpal)+
theme_classic() + theme(axis.text = element_text(color='black')) +
geom_smooth(se=FALSE, size=1, aes(group=Version)) +
geom_point(data=df, aes(x=time*22, y=response, color=Version), alpha=0.5, size=1.2)
# theme(legend.position='top') +
ggsave('Smoothed_spaghetti_groups.pdf', width = 4, height = 3, dpi=600)
########## FPC curves ###### (need to automatic ACT different number of PCs)
pdf('FPCs.pdf', width=5, height=8)
plot(time_cont*22, FPC_mean[, 1], type="l", lwd=2, ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),
xlab='time', ylab='PC Curve Values', cex.lab=1.2, col='red')
lines(time_cont*22, FPC_mean[, 2],type="l",lwd=2, col='blue')
title(main=paste("FPCs for", "response"))
legend('topright', c('PC1', 'PC2'), lwd=c(3, 3), col=c('red', 'blue'), bty='n')
dev.off()
pdf('FPCs_mean.pdf', width=5, height=8)
par(mfrow=c(2,1))
for (k in 1:K){
plot(time_cont, Mu_functions, type="l", ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),
lwd=2,col=1, xlab='Time', ylab='pH', cex.lab=1.5)
lines(time_cont, Mu_functions + FPC_mean[,k],type="l",lwd=3,lty=2,col=2) # red
lines(time_cont, Mu_functions - FPC_mean[,k],type="l",lwd=3,lty=2,col=3) # green
title(main=paste("Effect of FPC", k , "for", "pH"))
}
legend('topright', c('+ pc', '- pc'), lty=c(2,2), lwd=c(3,3), col=c(2, 3), bty='n', cex=0.5)
dev.off()
#### predicted trajectories do not seem as good as before
pdf('predictedTrajectories.pdf')
par(mfrow=c(2,1))
i = 0
for (pid in unique(df$ID)){
i = i + 1
Y_i = Y_sparse[[i]]
times_i = time_sparse[[i]]
Fitted_i = Fits_sparse[[i]]
plot(time_cont, Mu_functions, type="n", ylim=c(min(unlist(Y_sparse)), max(unlist(Y_sparse))),
lwd=2, col=4, xlab="Time", ylab="pH")
lines(times_i, Y_i, type="l", col=4, lty=2)
lines(times_i, Fitted_i, type="l", col=4)
title(main=paste("Fitted", "pH", "for subj", pid))
}
dev.off()
########## analysis with principle component scores ######
#### (warning: df is long formatted; convert to wide format for lm? or take unique ID only?)
library(ggpubr)
library(gridExtra)
pdf('fpcScores_ggBoxplot.pdf', width=10, height=8)
### p-values based on T test (same as from simple linear regression)
compare_means(fpc1 ~ Version,  data = df, method = "t.test"
my_comparisons <- list(c("baseline", "shift_1x"), c("baseline", "shift_2x"),
c("baseline", "shift_4x"))
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
plot1 = ggboxplot(df, x = "Version", y = "fpc1",
color = "Version", palette = colpal)+
stat_compare_means(comparisons = my_comparisons, method = "t.test") +
theme(text = element_text(size=12),
axis.title.x = element_text(size=18, face="bold"),
axis.title.y = element_text(size=18, face="bold"))  # Add pairwise comparisons p-value
compare_means(fpc2 ~ Version,  data = df, method = "t.test")
my_comparisons <- list(c("baseline", "shift_1x"), c("baseline", "shift_2x"),
c("baseline", "shift_4x"))
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
plot2 = ggboxplot(df, x = "Version", y = "fpc2",
color = "Version", palette = colpal)+
stat_compare_means(comparisons = my_comparisons, method = "t.test") +
theme(text = element_text(size=12),
axis.title.x = element_text(size=18, face="bold"),
axis.title.y = element_text(size=18, face="bold"))
grid.arrange(plot1, plot2, ncol=2)
dev.off()
# scatterplot of PC scores
ggplot(df, aes(x=fpc1 , y=fpc2)) + geom_point() +
aes(colour=factor(Version)) + theme(legend.position="top") +
scale_color_manual(values=colpal) +
theme(text = element_text(size=12),
axis.title.x = element_text(size=18, face="bold"),
axis.title.y = element_text(size=18, face="bold"))
ggsave('scatterplot_scores.pdf', width=6, height=5)
compare_means(fpc1 ~ Version,  data = df, method = "t.test"
my_comparisons <- list(c("baseline", "shift_1x"), c("baseline", "shift_2x"),
c("baseline", "shift_4x"))
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
plot1 = ggboxplot(df, x = "Version", y = "fpc1",
color = "Version", palette = colpal)+
stat_compare_means(comparisons = my_comparisons, method = "t.test") +
theme(text = element_text(size=12),
axis.title.x = element_text(size=18, face="bold"),
axis.title.y = element_text(size=18, face="bold"))
compare_means(fpc2 ~ Version,  data = df, method = "t.test")
my_comparisons <- list(c("baseline", "shift_1x"), c("baseline", "shift_2x"),
c("baseline", "shift_4x"))
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
plot2 = ggboxplot(df, x = "Version", y = "fpc2",
color = "Version", palette = colpal)+
stat_compare_means(comparisons = my_comparisons, method = "t.test") +
theme(text = element_text(size=12),
axis.title.x = element_text(size=18, face="bold"),
axis.title.y = element_text(size=18, face="bold"))
pdf('fpcScores_ggBoxplot.pdf', width=10, height=8)
### p-values based on T test (same as from simple linear regression)
compare_means(fpc1 ~ Version,  data = df, method = "t.test")
my_comparisons <- list(c("baseline", "shift_1x"), c("baseline", "shift_2x"),
c("baseline", "shift_4x"))
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
plot1 = ggboxplot(df, x = "Version", y = "fpc1",
color = "Version", palette = colpal)+
stat_compare_means(comparisons = my_comparisons, method = "t.test") +
theme(text = element_text(size=12),
axis.title.x = element_text(size=18, face="bold"),
axis.title.y = element_text(size=18, face="bold"))  # Add pairwise comparisons p-value
compare_means(fpc2 ~ Version,  data = df, method = "t.test")
my_comparisons <- list(c("baseline", "shift_1x"), c("baseline", "shift_2x"),
c("baseline", "shift_4x"))
colpal <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7")
plot2 = ggboxplot(df, x = "Version", y = "fpc2",
color = "Version", palette = colpal)+
stat_compare_means(comparisons = my_comparisons, method = "t.test") +
theme(text = element_text(size=12),
axis.title.x = element_text(size=18, face="bold"),
axis.title.y = element_text(size=18, face="bold"))
grid.arrange(plot1, plot2, ncol=2)
dev.off()
